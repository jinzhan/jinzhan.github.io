{"meta":{"title":"问津的读书笔记和思考日记","subtitle":null,"description":"Where there is a will there is a way.","author":"Jinzhan","url":"http://jinzhan.github.io"},"pages":[{"title":"404","date":"2016-01-27T16:00:03.000Z","updated":"2018-11-25T16:08:34.370Z","comments":true,"path":"404/index.html","permalink":"http://jinzhan.github.io/404/index.html","excerpt":"","text":""},{"title":"About me","date":"2016-01-27T15:45:15.000Z","updated":"2018-11-25T16:08:34.377Z","comments":true,"path":"about/index.html","permalink":"http://jinzhan.github.io/about/index.html","excerpt":"","text":"A developer and designer."},{"title":"tags","date":"2016-01-27T15:45:38.000Z","updated":"2018-11-25T16:08:34.379Z","comments":true,"path":"tags/index.html","permalink":"http://jinzhan.github.io/tags/index.html","excerpt":"","text":""},{"title":"资源汇总","date":"2016-02-14T10:08:18.000Z","updated":"2018-11-25T16:08:34.378Z","comments":true,"path":"resource/index.html","permalink":"http://jinzhan.github.io/resource/index.html","excerpt":"","text":"手册CSS Css3动画手册 Markdown Markdown 语法说明 Markdown 简明语法手册 Markdown 公式指导手册 技术图谱 Platform WebFrontEndStack Frontend Knowledge Structure 综合 Overapi Devdocs Apidocs 工具Markdown编辑器 Cmd Markdown 编辑阅读器 在线编辑器 代码美化/对照 Fehelper CodeCompare Jscompress Css Beautifier Csscomb Cssfmt css处理 Less(中) Less(英) Less工具est Sass Sass中文文档 Stylus Cssgrace Cssreset Postcss Css2less Sublime-Autoprefixer Purifycss Css小工具 Css3pie Csslint IE’s css3 图片压缩/合并 Placehold Tinypng Gopng Spritegen Spritecow Zhitu 在线制作 Css3generator Caret Cssarrow Css-Triangle-Generator Css3maker Cubic-Bezier Ceaser Css3button Enjoycss Createcss3 Flexyboxes Type-scale Gradient-Editor Csscreator Keyframes Calculator Bootstrap Layoutit FormStyleGenerator 转换工具 Img to Txt Px-Em Onlinefontconverter Freefontconverter Daxiaoxie 繁简字体转换 Liantu(二维码) Puretext（富文本粘贴为纯文本） Ps to Css Gif-Video Html-Markdown Html-Pdf 项目管理 Grunt Gulp Webpack Fis Npm Packagecontrol 检测/测试 IETester IE官方测试大礼包 w3c css验证 w3c html验证 Jslint Html5 Outliner Typetester Nth-test Webfonts Css3test 多终端检查/测试 Responsinator Resizemybrowser Responsive Juicer Responsivepx Browsersync Mobile Validator(移动端代码检测) Mihtool 兼容/性能/数据查询 Screensiz Caniuse Whatwebcando Browserhacks Csstriggers Modernizr Css4-selectors 腾讯大数据 友盟指数 cnzz数据中心 性能测试 Httpwatch Fiddler Gtmetrix Webpagetest Pagespeed 综合 Frontend-tools Fetool Testdrive Tool.css-js Cleancss Atool 在线工具大全 前端工具集与站点整理 Adobe一家 设计和前端工具集合 其他 截屏测量UI距离 自动刷新浏览器 web开发各种性能工具 代码在线演示 Jsfiddle Jsbin Jsdo it Cssdesk Runjs Online-Code-Editor Ideone Codepen Dabblet 常用组件/插件综合 Dowebok KitJs Effeckt 触屏滚动 TouchSlide Swiper Owlcarousel Superslide2 iSlider FullPage Zepto.fullpage 日期选择器 jquery-frontier-calendar datetimepicker pickadate flipclockjs jq-timeTo glDatePicker calendarsPicker 图表 Echarts Highcharts(中) Highcharts(英) Jscharts Chart Taucharts 弹出层 sweetalert animatedModal layer 其他 下拉刷新、上拉加载 懒加载 textarea自适应高度 多行文本溢出clamp-js 多行文本溢出dotdotdot Letter-by-Letter html5shiv(低版本浏览器的HTML5支持) jquery-placeholder Js复制 框架/库UI Bootstrap(英) Bootstrap(中) Yui Foundation Jeasyui Metroui Semantic Purecss Basscss Jqueryui Css3lib Uikit js Jquery Zeptojs Angularjs(英) Angularjs(中) Angularjs社区 React(英) React(中) Jslite validate表单验证 Vuejs官方论坛 Backbonejs Avalonjs Thinkjs Expressjs Seajs 动画库 Animate Anicollection Cssshake Animatable Hover Animations JXAnimate Spinkit Velocity动画 AlloyStick骨骼动画引擎 Rocket Cssynth Stylie Animo-js Anima Magic_animations Dynamicsjs Anijs Motio Snabbt Textillate Animsition Parallax FakeLoader Wow Bouncejs Move Easie iGrowl Morf Transit Greensock 字体图标 Loveiconfonts Glyphter Perfecticons Xiconeditor Fontello Iconfont Icomoon Font-Awesome Glyphicons Google Material Design 资源库 百度静态资源共享库 Taobaonpm Bootcdn Javascripting Microjs TodoMVC 方案荟萃布局 垂直居中 css完全居中 居中之美 Flexbugs Retina屏1px线 多行溢出省略 textarea高度自适应 页面高度100% 网页中的底部foot定位 移动端 腾讯移动web整体解决方案 腾讯移动web前端知识库 移动界面尺寸规范 点击事件背景框 支付宝无线开发经验 saber移动web解决方案 响应式还是分开写 移动端position:fixed问题 MetaHandler（网易移动前端适配无痛脚本） 其他 IF IE ENDIF条件判断之IE10 Chrome 翻译插件 网页retina优化 常用meta 树状菜单 em vs rem css vs js css解决方案（w3cplus） Textures生成纹理 CSSgram Csscss（检查重复声明等） 常见问题前端指路 写给前端面试者（w3cplus） 如何成为一名卓越的前端工程师（勾三股四博客） 什么是全栈工程师 如何跟上前端开发的最新前沿 浏览器的工作原理 移动前端开发和 Web 前端开发的区别 大型网站CSS编写与维护 CSS核心技术关键字 性能/规范/实践 如何阅读W3c规范(王晓轩) 如何阅读W3c规范(高博) 雅虎web性能优化军规 前端规范 codeguide 权威前端性能指南 ecomfe-spec Code Review jquery 使用实践 高性能css MDN-Guide BEM BEM-w3cplus NEC JavaScript Style Guide Css-Code-Review Css Frontend Guidelines Node Style Guide React Style Guide Code Guide By Materliu Google设计规范 问答社区 知乎 quora stackoverflow segmentfault问答区 前端乱炖问答区 资料 Awesomes Awesome-css Awesome-css中文版 Awesome-javascript中文版 Webdesignrepo（很棒的英文网址导航） wwwhere Nodejs中文资料导航 AngularJS信息资源大全 Angular学习资源合集 cNodejs ES6 overview 百度IFE 前端收藏夹 Github资源收集 Responsive resources响应式大全 书籍HTML HTML 5与CSS 3权威指南(上册)(第2版) HTML5秘籍(第2版) HTML5与CSS3基础教程(第8版) CSS CSS权威指南(第3版) 精通CSS:高级Web标准解决方案(第2版) CSS禅意花园(修订版) CSS设计指南（第3版） CSS-Secrets 精彩绝伦的CSS 图解CSS3:核心技术与案例实战 CSS3秘籍(第3版) CSS3实战 众妙之门:精通CSS3 CSS那些事儿 Javascript JavaScript高级程序设计(第3版) JavaScript权威指南(第6版) JavaScript DOM编程艺术(第2版) JavaScript语言精粹(修订版) 编写可维护的JavaScript JavaScript模式 JavaScript函数式编程 JavaScript框架设计 锋利的Jquery jQuery权威指南(第2版) React:引领未来的用户界面开发框架 用AngularJS开发下一代Web应用 AngularJS权威教程 深入浅出Node.js Node.js 官方文档中文版(kindle) Node学习指南 了不起的Node.js: 将JavaScript进行到底 ppk谈JavaScript 综合 编写高质量代码:Web前端开发修炼之道 Web前端开发最佳实践 高性能网站建设指南:前端工程师技能精髓 高性能网站建设进阶指南：Web开发者性能优化最佳实践 Web全栈工程师的自我修养 重构：改善既有代码的设计 在线书籍 前端开发手册 前端开发笔记 Git Community Book 中文版 react-webpack-cookbook A Compact React Cookbook Webpack中文指南 ES6入门 Eloquentjavascript nodejs入门 （英） nodejs入门 （中） sublime手册 参考书单 程序员必读书单 oozled-books 免费的编程中文书籍索引 前端推荐阅读书籍 front-end-books-recommend list of javascript books 教程综合 慕课网 codeschool codecademy codewars 百度前端技术学院 w3school runoob busy前端工作室 hackr 浏览器 Chrome基础功能篇 Chrome进阶篇 Chrome 性能篇 Chrome 性能进阶篇 Chrome Chrome 移动篇 Chrome 插件篇 IDE/编辑器 快乐的sublime Sublime Text 3使用心得 Sublime Text3使用总结 Sublime Text 3实用功能和常用快捷键收集 Sublime Text 全程指南 Sublime学习资源 Best of Sublime Text 3 Colorsublime配色 Sublime-text-github Vim常用插件 Atom编辑器快捷键大全 版本控制工具 Git Git教程（廖雪峰） 版本管理工具介绍—Git篇 Git 使用规范流程 够用一年的Git 技巧 Git速查表大全 Git tutorials CSS/布局 HTML+CSS基础课程 网页布局基础 固定层效果 回到顶部效果 CSS Sprite雪碧图应用 CSS深入理解之line-height CSS深入理解之overflow CSS深入理解之float浮动 CSS深入理解之absolute Css3-Tutorial Flexbox Flexboxfroggy(小游戏) Atozcss Css-101 Cssplay javascript MDN JS教程 JavaScript 标准参考教程（alpha） Jstherightway Superherojs Javascriptissexy Try-Jquery 动画 CSS动画实用技巧 数学知识在CSS动画中的应用 全屏切换效果 animation rocks Sass Sass入门篇 Sass进阶篇 Sass-Guideline中文网 Canvas Canvas教程（MDN） Canvas API方法和属性汇总 倒计时效果Canvas绘图与动画基础 Canvas绘图详解 Canvas玩转图像处理 svg svg系列文章 走进SVG markdown markdown入门大全 markdown教程 中文综合 w3c中国 w3help w3cplus w3ctech css88 div.io 前端观察 前端乱炖 大前端 一流前端 web前端资源网 前端早读课 前端开发博客 segmentfault IE10开发人员指南 blueidea 极客标签 HTML5中国 HTML5学堂 imweb 前端里 前端范 最虾米 web技术研究所 w3cmark w3ctrain web资料站 英文综合 smashingmagazine htmldog slideshare MDN csszengarden css-tricks dev opera sitepoint codrops html5devconf webdesignerdepot sixrevisions github oreilly tutorialzine getawesomeness html5rocks tutsplus tutorialrepublic quackit html5andbeyond blogs.windows scotch webresourcesdepot perfectionkills oozled softwareengineeringdaily 国内团队 奇舞团 携程UED 百度FEX 迅雷CUED 腾讯Alloyteam 腾讯TGideas 腾讯TID 腾讯CDC 腾讯ISUX 淘宝UED 淘宝前端团队 1号店MXC 大搜车团队 alimama 微信企业号 美团技术团队 微博UDC 国内个人 winter css森林 twinsen 尤小右 阮一峰 张鑫旭 余果 贤心 大猫 franky 前端农民工 sofish 玉伯 拔赤 堂主 嗷嗷 一丝 一丝new 米粽粽 勾三股四 贺师俊 张克军 真阿当 doyoe css魔法 99css Toobug 随机 三水清 严清 justjavac 叶小钗 米随随 进步博客 练小习 小胡子哥 情封 任平生 当耐特 豪情 小李刀刀 Lucida 屈光宇 luopq 涂鸦码龙 夏天的森林 汤姆大叔 老赵 三生石上 司徒正美 丸子 阿肆 梦想天空 ALSOTANG’S 马天翼 黄玄 珍妮 丁小倪 题叶 桑尼真 melonh 怿飞 水墨寒 党建 zibin materliu 笨笨剥壳 hzlzh 萝卜 元彦 鬼道 白树 前端小武 spy 轩枫阁 西门的后花园 草依山 于江水 苏洋 周文彬 颜海镜 崔凯 彬Go 龙恩0707 alien 乐小希 Dtao hacke2 trigkit4 dead-horse 一米 凯凯刘 王牧天 淡忘~浅思 武方博 阿安 rex 羡辙 busy 国外个人 alvarotrigofullPage.js作者 Eric Meyer《css权威指南》、《精彩绝伦的css》作者，著名css专家 philipwaltonFlexbugs创建者 cameron moll精通CSS：高级Web标准解决方案 作者之一 andy budd精通CSS：高级Web标准解决方案 作者之一 Lea Verou《css secret》作者 JohnResigJquery作者 Nicholas C. Zakas《Javascript高级程序设计》作者 useragentmanIE’s css3作者 addyosmani《Learning JavaScript Design Patterns》作者 Nicholas ZakasHigh Performance JavaScript 作者 Paul IrishHTML5 Boilerplate 发起人之一 Peter Koch主要是 JavaScript API Douglas CrockfordJSLint、《语言精粹》作者 Dustin Diaz前 Google，现 Twitter Alex RussellChrome team 成员 ejohn davidwalsh Charles Wyke-Smith《CSS设计指南》作者 设计设计名站 站酷 优设 昵图网 懒人图库 千图网 独创意 视觉中国 idesign设计导航 配色方案 colorhexa webcolourdata colourlovers color-wheel peise websafecolors IT行业 infoq 伯乐在线 异步社区 推酷 久艾分享 技术刊物 百度FEX 奇舞周刊 好东西论坛 技术头条 javascriptweekly html5weekly feweekly 懒懒小报 前端 webrebuild jsconfchina cssconf css小组 js小组 前端技术分享网 网易杭州前端技术部 w3ctech 专注web前端开发 移动web前端设计 F2E前端技术社区 前端开发网站 前端开发博客 divio前端社区 慕课网前端学习小组 前端网 前端大全 前端交流 前端早读课 SegmentFault w3cplus w3c中国 HTML5中国 HTML5 HTML5kit w3cmark 前端乱炖 前端快爆 前端网W3cfuns 设计 优秀网页设计 UI中国 UC优视RED设计中心 腾讯CDC体验设计 交互设计UI 综合 稀土圈 技术头条 好东西传送门 活动 前端圈走进名企 Segmentfault D-DAY 会议 Webrebuild Cssconf Jsconf Adc·阿里技术嘉年华 Feday D2前端技术论坛 编程人生 我的软件开发生涯 (10年开发经验总结和爆栈人生)灵感之源 在腾讯的第四个两年鬼哥 腾讯5年余果 写给初学前端工程师的一封信张克军 前端路上的旅行大漠 话说我为什么要闭关学习张鑫旭 程序员所具备的素质[转]随机 重构职业生涯思考丁小倪 你为什么不分享CoffeeDeveloper 技术好文 一览CSS布局标准张克军 视觉格式化模型中的各种框doyoe Margin系列doyoe 重拾 CSS 的乐趣（上）css魔法 重拾 CSS 的乐趣（下）css魔法 Web前端开发最佳实践系列党建 深入理解javascript系列汤姆大叔 关于reset那些事儿系列alsiso 说说CSS学习中的瓶颈张鑫旭 达人专访 大搜车前端负责人@芋头君前端早读课 腾讯微信支付设计中心重构负责人@Ghostzhang前端早读课 百度高级前端开发工程师@叶小钗前端早读课 手机百度前端负责人@三水清前端早读课 腾讯高级前端工程师@余果前端早读课 一文惊人的高工晓思SegmentFault GitHub创始人 Preston-Werner专访：GitHub如何成为主流SegmentFault 专访《硅谷百年史》作者：人们不想以旧的方式生活，却不知道自己想要什么图灵访谈 郝培强（@Tinyfool）：创造的乐趣图灵访谈 对话豆瓣张克军：前端，工程与人infoq 腾讯 Qzone 系统架构设计选型与变迁infoq Qzone前端团队的最佳实践：面向运营infoq 对话百度前端工程师张云龙：F.I.S与前端工业化infoq 大众点评资深前端工程师张颖：一站式的前端开发infoq Demo demo.doyoe one-div w3cplus-demo-list 一些有意思小demo ShapesOfCSS css-loaders loaders 26字母 css-cursor 备注：来源于f2er.club的收集整理"},{"title":"Links","date":"2016-01-28T03:36:26.000Z","updated":"2018-11-25T18:12:37.738Z","comments":true,"path":"links/index.html","permalink":"http://jinzhan.github.io/links/index.html","excerpt":"","text":"Source front-end-handbook scotch.io BFE 75team tmallfe CSS Sans perfectionkills.com smashingmagazine.com codepen.io My Post My Pen Effect a single div FWA Online Learning codecademy study.163.com - college course study.163.com - internet course Books Learning JavaScript Design Patterns Exploring ES6 Appendix A: Webpack for React modern-frontend-tooling Pictures unsplash gratisography Color Blending colorhexa web colour data color wheel Friends 颜海镜 专注Web前端 Fun EMOJI CHEAT SHEET LeetCode js fun Else front-end-bookmarks"}],"posts":[{"title":"三国史话","slug":"2018/三国史话","date":"2018-11-25T16:53:12.000Z","updated":"2018-11-25T17:12:15.993Z","comments":true,"path":"11/26/2018/三国史话/","link":"","permalink":"http://jinzhan.github.io/11/26/2018/三国史话/","excerpt":"","text":"关于作者本书作者是中国史学界泰斗吕思勉先生，他与钱穆、陈垣、陈寅恪并称为“现代中国四大史学家”。先生一生的著作超过1000万字，每一部都有极高的学术价值，尤其是他集毕生之力编写的《中国通史》，以及《先秦史》《秦汉史》《两晋南北朝史》和《隋唐五代史》四部断代史，都是后来学者的必修书目。正因为先生学术功底深厚，所以他对历史上的关键人物和事件总有独到的见解，甚至经常打破人们对某些历史事件的普遍认知。 关于本书这本《三国史话》，是一本颠覆了我们对三国传统印象的书。在书中，你会发现民间被视为“仁德”代名词的刘备，其实也有腹黑的一面；而常常被当做奸雄的曹操，却对历史的发展做出了巨大贡献；甚至经常被忽视孙权却其实是决定三足鼎立局面形成的关键人物。吕思勉先生在书中对三国时期重要的历史人物和历史事件，结合当时复杂的社会环境的条件，进行了客观的分析，从而还原历史本来的面貌。 核心内容多数人了解三国都是通过《三国演义》这本著作，但是我们知道，《三国演义》是一部小说，小说就要体现作者的价值观，那《三国演义》的价值观是什么呢？是拥汉贬曹，宣扬忠义。所以它抬高刘备，反对曹操，神化了诸葛亮和关羽，而袁绍、孙权这些在当时举足轻重的人物却被淡化了。受到演义的影响，人们看三国难免会主观先行，为这些人扣上或英雄或奸佞的帽子。但其实历史人物，是很难简单的用一两句话概括的，必须要结合他们所处的复杂环境，才能客观的进行评判。 前言本书大概16万字，我会用大约30分钟的时间为你讲述书中的主要内容：如何公正地评判三国时期的历史人物和历史事件。 三国这段历史可以说是脍炙人口，有关三国的书籍也是相当多，像正史有陈寿的《三国志》，点评类的有易中天老师的《品三国》，传记类还有张作耀先生的刘备、曹操、孙权传。但最出名的当然要属罗贯中的《三国演义》了。 大多数人了解三国都是通过这本著作。但是我们也知道，三国演义》是一部小说，小说就要体现作者的价值观，那《三国演义》的价值观是什么呢？是拥汉贬曹，宣扬忠义。所以它抬高刘备，反对曹操，神化了诸葛亮和关羽，而袁绍、孙权这些在当时举足轻重的人物却被淡化了。受到演义的影响，人们看三国难免会主观先行，为这些人扣上或英雄或奸佞的帽子。但其实历史人物，是很难简单地用一两句话概括的，必须要结合他们所处的复杂环境，才能客观地进行评判。而我们这次要说的这本《三国史话》，就是要对三国时期重要的历史人物和历史事件，结合当时复杂的社会环境的条件，进行客观地分析，来还原历史本来的面貌。 本书作者是中国史学界泰斗吕思勉先生，他与钱穆、陈垣、陈寅恪并称为“现代中国四大史学家”，先生一生的著作超过1000万字，每一部都有极高的学术价值，尤其是他集毕生之力编写的《中国通史》和《先秦史》《秦汉史》《两晋南北朝史》《隋唐五代史》四部断代史，都是后来学者的必修书目。正因为先生学术功底深厚，所以他对历史上的关键人物和事件总有独到的见解，甚至打破人们对某些历史事件的普遍认知。比如我们这次要说的这本《三国史话》，就是一本颠覆了我们对三国传统印象的书。在书中，你会发现民间被视为“仁德”代名词的刘备，其实也有腹黑的一面；而常常被当做奸雄的曹操，却对历史的发展做出了巨大贡献；甚至经常被忽视的孙权却成了决定三足鼎立局面形成的关键人物。 好，介绍完作者和作品的一些概况，接下来我们就详细了解下这本书。本期音频中，我一共会从四个方面入手为你解读这段历史。第一，为何刘备刚刚建立起蜀汉政权，就遭遇两次惨败？第二，对促成三足鼎立局面起决定作用的孙权为何会被忽视？第三，如何评价曹操的功过？第四，如何从现在的视角评价历史人物？ 第一部分我们先来看第一个问题：为何刘备刚刚建立起蜀汉政权，就遭遇两次惨败？ 看过《三国演义》的人都有这样一个印象，刘备是一位礼贤下士、道德高尚的明主，他的蜀汉政权更是汉室正统。我们也知道他早年一直郁郁不得志，到赤壁之战后，才慢慢站稳脚跟，后来终于有机会夺了益，也就是现在四川一带，才建立起了蜀汉政权。刘备是在公元214年夺取的益州，然后在公元219年夺取汉中，之后就自立汉中王，这也是刘备一生最风光的时候。然而就在刘备称王的这一年，关羽败走麦城，他统辖的荆州被孙权夺了，紧接着在公元222年，刘备又在夷陵之战中，被东吴的陆逊火烧连营，全军覆没。一年后，他就在白帝城郁郁而终。读《三国演义》的时候，我们看关羽败走麦城和刘备白帝城托孤，都不免为他们感到惋惜，那我们不禁要问了，刘备为什么刚刚建立起蜀汉政权，就连遭两次惨败呢？刘备真如文学作品中描写的那样，是一位明主吗？ 吕思勉先生在讨论刘备夺取益州的经过时，评价刘备“太工于心计而缺少正义”。这句话一出，不知道颠覆了多少人对刘备的认知。刘备在《三国演义》中几乎是仁德的代名词，那吕思勉先生为什么会说他工于心计呢？我们来看下刘备是如何夺取益州的。 刘备在进入益州之前，他只占有荆州的五个郡，大概位于现在湖北湖南一带，当时的益州是刘璋的领地，而曹操已经基本统一了北方，西北的凉州也就是现在甘肃一带，有马超和韩遂，汉中还有张鲁，这就是当时的天下形势。 那刘备是怎么进入益州的呢？其实是益州的刘璋把他请进去的。公元211年，曹操要对西北用兵，想要兼并凉州和汉中，这时候益州的刘璋可就紧张了，因为一旦曹操拿下汉中，下一个目标就是自己了。而刘备和刘璋都是汉室宗亲，所以刘璋想请刘备这个亲戚来帮忙，抢在曹操前头夺取汉中。结果他没想到这竟然是引狼入室，刘备到益州就赖着不走了，最后还反客为主，把刘璋赶下了台，自己占了益州。这就是刘备取益州的始末，真谈不上什么道义。而且就在刘备夺取荆州的时候，曹操战胜了马超和韩遂，随后又占领了汉中，而此时刘备要再取汉中，就要独自与曹操正面交锋了。这也成了刘备失荆州的重要因素。 关羽大意失荆州的故事我们都知道，关羽从荆州北上要攻取樊城，结果东吴的吕蒙趁着荆州空虚，占领了荆州，最后关羽只能败走麦城。那关羽为什么要从荆州北上呢？根据吕思勉先生的分析，关羽出兵，是因为要配合刘备进军汉中，来牵制曹操的后方。但是刘备取汉中本来是不需要关羽配合的，为什么这么说呢？因为如果刘备当时老实一点，先帮刘璋在曹操前头拿下汉中，那时候马超和韩遂还没被曹操击败，就可以彼此联合，对抗曹操。结果刘备太工于心计，不去汉中，反而占了益州，这就在无意中帮了曹操一个大忙，让曹操有充足的时间战胜马超和韩遂。刘备这时候再出兵汉中，就只能独自面对曹操了，所以才必须要关羽在荆州来牵制曹操的后方，这才让吕蒙乘虚而入。 丢失荆州也就直接引发了后来的夷陵之战，对于刘备要出兵伐吴的原因，《三国演义》中说是为了替关羽报仇，但吕思勉先生分析并不是这样的，因为刘备伐吴已经是在关羽死后一年半了，真正有王者气概的人，早就该冷静下来了。刘备选择伐吴，是因为他知道北上攻魏他还没这个实力，但是把荆州夺回来，他还是有自信的，所以就先拿东吴开刀。 这个说法或许值得商榷，但是根据金文京先生在《三国志的世界：后汉三国时代》一书中分析可以知道，刘备夺取益州用的是不正当手段，益州本地士人很难真心臣服，他在益州的基础并不牢靠。相反，刘备是在荆州起家的，主要将领、谋臣都是跟随他从荆州过来的，所以荆州相当于刘备的根基所在。最关键的，荆州是当时的战略要地，它北靠汉水，东连吴地，西通巴蜀，是兵家必争之地，因此荆州必须要夺回来的。但是刘备这次低估了孙权的实力，结果兵败夷陵，一年后死于白帝城。 所以刘备失荆州败夷陵的结果，其实在他用不正当的手段夺取益州时就已经决定了。吕思勉先生最后在评价刘备时就感慨：“真个阅历多的人，倒觉得凡事还是少用机谋，依着正义而行的好了”。 好，以上就是我们要讨论的第一个话题：为何刘备刚刚建立起蜀汉政权，就遭遇两次惨败？按照吕先生的分析是他在益州问题上太过工于心计，缺少正义造成的。 第二部分刘备失荆州败夷陵，获利最多的当数孙权了。不过很奇怪，孙权每次都在最重要的历史时刻出现，三国时期三大战役官渡之战、赤壁之战、夷陵之战，其中两个都有他参与，而且他都是胜利者，但是他却很少受到重视。这是为什么呢？这就是我们要讨论的第二个问题：对促成三足鼎立面起决定作用的孙权为何会被忽视？ 无论是《三国演义》，还是其他的文学作品，孙权给人的感觉就是要守住江东的一亩三分地，好像从未有什么雄心大志。那孙权真的就是三国的配角吗？当然不是，孙权是对促成三足鼎力局面起决定性作用的人，为什么这么说呢？我们不妨先来看下赤壁之战。 赤壁之战我们都知道，孙刘联军一把大火烧退了曹操的百万大军，也正是这场战役决定了日后天下是统一还是继续分裂。吕思勉先生指出，如果此战曹操胜了，那么曹操就有机会统一全国，而曹操败了，他就暂时无力南下，孙权和刘备就有机会瓜分南方的疆土。那孙权对这场大战有什么影响呢？我们知道孙权一直是坐镇后方的，冲锋陷阵的是周瑜。其实，周瑜之所以能够在前线施展拳脚，完全是因为孙权力排众议坚持联刘抗曹的结果，而且要做这个决定，是非常需要魄力和勇气的。我们来看下孙权决心抗曹的原因。 《三国演义》中描写孙权下决心这段可以说是非常精彩，诸葛亮舌战群儒，智激周瑜，最后周瑜向孙权表决心，让人看得热血沸腾。真实的历史虽说没有演义那么夸张，但孙权确实是在周瑜、鲁肃等人的劝说后才做的决定。我们来看下周瑜和鲁肃是怎么劝说的。 周瑜是通过政治和军事两个方面向孙权分析的。周瑜上来就强调“曹操虽托汉相，实为汉贼”。不过这和孙权有什么关系呢？孙权也没说要复兴汉室，反倒是鲁肃在赤壁之战的10年前就对孙权说过一句“汉室不可复兴”，这不是自相矛盾吗？所以周瑜这句对孙权来说不过是句空话，那周瑜后来又说了什么呢？他列举了三项曹操的军事弱点：后方不稳、不善水战、粮草不足。不过就这三点就让孙权相信周瑜能赢了吗？保守估计曹操20万大军，孙权刘备加起来不过5万，而且曹操刚拿下荆州，士气正盛，反倒是江东士族一片投降论调。这样看来孙权这边弱点反倒比曹操更明显。所以孙权绝对不会因为周瑜几句话就热血沸腾，那是莽夫之举。 孙权究竟为何选择迎战的呢？我们再来看下鲁肃的话，他是这样说的：“像我是可以投降曹操的，你却使不得。为什么呢？我在你手下，不过做个官，我投降了曹操，还可以继续做官。而主公你呢？你投降后最多封个侯，不过配一辆车、一匹马，带几个随从，这样主公你还能南面称孤吗？”南面称孤这四个字才是孙权真正要联刘抗曹的原因。孤是帝王对自己的称呼，孙权是早有称霸天下的雄心。也正是因为他这份雄心，让周瑜可以在前线毫无后顾之忧地施展拳脚，最后在赤壁之战取胜，这才有了三足鼎立的局面。 那为什么人们总是看不到孙权的雄心大志呢？那是因为孙权是一个城府很深的人，他把自己的野心隐藏了起来，不到最后绝不暴露出来。为什么这么说呢？我们来看下孙权在夷陵之战前后的表现。 当时刘备大军压境，孙权必须防止北方的曹丕趁火打劫，所以他竟然向曹丕称臣，要知道当时曹丕和刘备都已经称帝了，此时孙权竟然可以委曲求全，这种忍耐真不是一般人能做到的。 不过你可能会问了，这不只能说明孙权胆小吗，表面上看确实是这样，但是孙权向曹丕称臣之后，在一件事上却暴露了他绝非胆小怕事。那就是他没有改用曹魏的年号。年号在古代可以说是皇权的象征，我们看三国经常说建安多少多少年，那个建安就是汉献帝的年号，明朝后很多皇帝都直接用年号来称呼了，像是崇祯、康熙、乾隆，这些都是皇帝的年号。而孙权却继续使用汉朝的年号，说明他并非真心向曹魏称臣，这只是权宜之计。两年后，孙权开始用自己的年号。这时候他已经和皇帝没什么区别了。8年后，公元229年，孙权终于在历经10年的韬光养晦后登基称帝。而孙权建立的吴国，是魏蜀吴三国里寿命最长的国家。 所以孙权并不是没有雄心，只是他对欲望有很强的控制力。赤壁之战是在他决定迎战后才发生的，也因此才有了后来三足鼎立的局面。之所以孙权在三国中的重要性会被忽视，是因为他善于隐藏自己的野心，不到最后绝不暴露出来。 以上就是我们要讨论的第二个话题：对促成三足鼎立局面起决定作用的孙权为何会被忽视？孙权的重要性经常被忽视或许对他有些不公平，不过在人们传统观念里，受到最不公平待遇的，当数曹操。曹操在民间几乎成了奸臣的代名词，京剧中的曹操都画着大白脸，那难道曹操真的就是生一副“白脸”吗？这就是我们要讨论的第三个话题：如何评价曹操的功过？看看历史上曹操的真实面目。 第三部分吕思勉先生在本书《替魏武帝辩诬》一章中，开头第一句话就是：“我现在，要替一位绝代英雄辩诬了。”这句开场，真可谓豪情万丈。吕思勉先生上来就为曹操下了个定义：绝代英雄。或许你会觉得吕思勉先生的说法有些夸张，那我们不妨来看下另一位历史学家田余庆先生在《秦汉魏晋史探微》一书中是怎么分析的。 田余庆先生认为对于曹操的评价应该分两点：第一，应该看他比别人多做了哪些好事，而不是看他做了哪些别人都做过的坏事；第二，主要看他所作所为的客观作用，而不是看主观动机。那通过这两个标准看曹操，他到底配不配得上绝代英雄这个称呼呢？我们知道对于曹操影响最大的有三件事：挟天子以令诸侯、官渡之战，还有统一中国北方。那我们就来看看曹操做的这三件大事。 挟天子以令诸侯可能是曹操身上最大的污点了，后世学者把曹操看做奸雄最大的依据就是曹操挟天子这一条。不过要说的是，和曹操同时代的诸侯几乎都有要挟天子或者当皇帝的想法。袁绍比曹操还早就要立出身皇族的刘虞作皇帝，而袁术干脆就自己称帝了，甚至一直提倡要复兴汉室的刘备，在刚听到汉献帝死亡的消息时就急忙称帝，根本没想去验证真伪，而事实上汉献帝根本没死。还有刚才我们说到的，鲁肃一早就对孙权说“汉室不可复兴”。也就是说，当时谁都没想过要忠于汉室，谁都想当皇帝，只不过被曹操抢得先机罢了。而且曹操到死也没敢篡汉称帝，所以田余庆先生说，曹操还是受传统礼教束缚的。而吕思勉先生认为他最后都执守臣节，在当时看来不能不说是一种美德。 我们刚才说评价曹操，该看他比别人多做了哪些好事，而不是看他做了哪些别人做过的坏事，所以因为他挟天子，就把他说成是白脸奸雄，是很不公平的，因为当时几乎所有人都有和曹操一样的想法。而且曹操迎奉天子之后，还建立了许多别人做不到的功绩。就像官渡之战，这是曹操统一北方的关键一战，而在这一战中取胜，可以说曹操是化不可能为可能，为什么这么说呢？我们先来看看曹操是在什么情况下取得胜利的。 官渡之战表面看就是曹操和袁绍之间的战争，但事实绝非这么简单。我们来看下曹操的身世，他父亲是宦官的养子，当时宦官是最让士大夫看不起的一类人，他们被称为“浊流”。那袁绍是什么人呢？袁氏家族当时被称为“四世三公”，三公在东汉是司徒、司空、太尉的总称，相当于丞相，也就是说袁绍家往上推四代都是位极人臣。有这样的政治资本，袁绍在当时作为统治阶层的士人集团中，声望极高，当时有影响力的世家大族，几乎全都站在袁绍一边。也就是说曹操是来自当时社会底层的寒门阶级，而袁绍代表的则是当时社会主流的士族阶级，官渡之战其实是他们二人所代表的各自阶级的一次较量。曹操是以最让人看不起的浊流寒门身份，对抗当时站在社会阶级最顶层的士人集团，曹操当时要承受的压力可想而知。 也正是因为顶着这种压力，曹操早期特别被动，他的政敌，他不敢轻易得罪；俘虏了敌方将领，他也不敢轻易惩罚；打败了豪强，他不敢轻易兼并。对自己的下属，他也只敢奖赏不敢开罪。甚至在官渡之战胜利后，他把自己下属和袁绍私通的信件全部烧毁，也不敢追查他们的叛逆行为。我们看《三国演义》都觉得曹操不可一世，谁能想到真实历史中的曹操这么憋屈。因为曹操知道，以自己的身世要得到天下人的支持，必须小心翼翼，稍有不慎，好不容易打下的疆土，会瞬间崩盘。其实就是他这么小心，官渡之战前他最担心的事还是发生了。 公元199年，也就是曹操和袁绍决战的前一年，刘备在徐州竖起反对曹操的大旗，东海昌豨举兵数万进攻曹操，此外南边的孙策也在秘密部署，准备袭击曹操的大本营许昌，汝南的黄巾军残余也受袁绍的鼓动反对曹操，更糟的是此时曹操统治下的百姓也对他失去了信心，纷纷向北方也就是袁绍的地盘迁徙，这让曹操连向百姓征税都不敢。此时的曹操真可以说是内忧外患、四面楚歌了。 就在这样极端不利的情况下，曹操依然可以稳扎稳打，步步为赢，和袁绍对峙一年多的时间。最后曹操终于抓住袁绍的弱点，偷袭了袁绍囤积军粮的乌巢，让袁绍军心大乱，这才取得了战争的胜利。在《三国演义》里袁绍是一个优柔寡断、刚愎自用的人。但是吕思勉先生却认为，袁绍在官渡战场上的表现并没有那么糟糕，他差点就把曹操逼得退兵了，所以我们也不能说曹操的成功全是因为袁绍的无能。曹操能赢是因为他胆气过人，关键时刻敢孤注一掷。 官渡之战看似是在曹操偷袭乌巢后发生转折，但是我们不得不说，偷袭乌巢这一次机会，是曹操在这四面楚歌的一年多里，坚持下来才换到的。他敢于以一己之力，和以袁绍代表的天下人对抗，而且可以在极端不利的局面中坚持下来，抓住转瞬即逝的胜机，这已经完全能够看出他的英雄气魄了。 官渡之战后，袁绍集团开始衰落，曹操最终统一了北方。这也可以说是曹操最大的历史功绩了。甚至可以说北方被曹操统一，也是一种幸运。为什么这么说呢？我们来对比下曹操和袁绍在官渡之战前的表现就知道了。曹操早在官渡之战之前，就开始下令屯田，恢复生产。他将荒废的田地租给当时无地可种的百姓，还分发给他们农具、耕牛和种子。同时他还将军田和民田分开，这样就让百姓不用担心徭役，可以安心生产。结果曹操统治下的军民丰衣足食。那他的对手袁绍在干什么呢？ 袁绍集团在河北可以说是极为骄奢，他为了拉拢当时的豪族，纵容他们大肆敛财，曹操攻下河北后，查抄袁绍手下重臣的家产，根据《三国志》记载收缴上来的物资钱财数以万计。这么多财产从哪来？肯定是从老百姓身上。其实就在曹操屯田的时候，袁绍的士兵甚至为了不饿死，去吃当时根本没人吃的桑葚。所以从这方面来讲，由曹操来统一北方，是让北方暂时脱离了以袁绍为代表的腐朽士族的压迫。 而曹操统一北方后，更是走上了一条与当时腐朽士族截然相反的政治路线，也就是寒门法家路线。他先是兼并豪强、打压世家大族，这样获利最多的就是中下层人民。此外曹操用人也是不拘一格，东汉选拔官员，是先看出身后看能力，而曹操却打破豪族对仕途的垄断，实行唯才是举。军事方面，他也是赏罚分明，有功者封侯，败军者抵罪。就这样，北方在曹操手里开始稳定发展，生产力得到恢复，经济也开始复苏。而且客观上看，这些也都为后来晋朝能统一全国，提供了物质和经济基础。我们说统一是中国历史的必由之路，曹操统一北方可以说是最大限度地完成了当时他能完成的历史使命。 从挟天子以令诸侯却最终不敢篡夺帝位、官渡之战和统一北方这几件事件看，曹操确实配得上绝代英雄这个称号。以上就是我们要讨论的第三个话题：如何正视曹操的历史形象？ 我们刚才通过曹操、孙权、刘备的分析，发现三国时期其实并没有我们想象的那么简单，每一个历史人物都是多面性的，我不能只根据一两件事就对一个人盖棺定论，那么我们到底该怎样从现在的视角评价这些历史人物呢？ 我们看看吕思勉、钱穆和田余庆先生这三位史学大师的观点。 我们总说“旁观者清，当局者迷”，但吕思勉先生却认为这只是旁观者不负责任的借口。在旁观者的角度是很难弄清当局者所处的环境的，要评价历史人物必须要站在当事人的角度去思考他所面对的问题。就像刚才我们讨论孙权，我们总觉得孙权只想偏安东南，却忽视了孙权所处的艰难政治环境，外部曹魏势力强大，内部江东的本土士人集团却只求自保，无心扩张。 赤壁之战，曹操大军来袭时这些江东士人更是一片投降论调。但就在这种内忧外患的情况下，孙权却毅然选择联刘抗曹。如果不站在孙权的角度去看当时的局势，就很难体会孙权下决心需要多大的勇气，也就很难发现孙权内心想要称霸天下的雄心。 另外，除了要站在当局者的角度去思考之外，我们还可以参考当事人所处时代的历史意见，什么是历史意见呢？这是钱穆先生在《中国历代政治得失》一书中提出的一个概念，他指的是在某种社会制度实施时代，人们所切身感受而发出的意见。比如刘备，我们总说他是明主，但这位人们口中的明主其实在益州并不得人心，刘备和诸葛亮为了维护荆州士人集团的利益，使得益州本地士人一直受到排挤，这也是为什么司马昭伐蜀时，益州士人全都支持投降的原因。所以如果从当时益州士人集团的历史意见来看，刘备肯定算不上明主。 当然，我们也不能只把目光局限在历史人物所处的时代，还应该将视角放大，就像刚才我们说的田余庆先生的观点，评价历史人物，应该看他所作所为在推动历史进程中所起的客观作用。所以我们才说统一中国北方的曹操，是最大限度地完成了他的历史使命，也因此他也配得上绝代英雄的称呼。 最后还要强调一点，历史人物都是有多面性的，是很难用一两句话说清楚的，因此我们做任何评判都应该限定在一个有限的范围内。比如曹操，他确实有历史功绩，但也不能否认他晚年心狠手辣，杀人不眨眼的事实。再比如刘备，我们虽然说他夺取益州时有违仁义道德，但也应该看到他白手起家，一生颠沛流离，屡战屡败却依然不曾放弃，反而越挫越勇，就这点而言刘备是一个很励志的人物。所以吕思勉先生认为对于历史，我们做任何评价，一定要谨守着一个范围，也因此，我们能说的话实在很少。然而就在我们能做的这为数不多的评论中，却多少可以看到一点历史的真相。 总结好了，以上就是我就《三国史话》这本书与你分享的内容，回顾一下。 首先我们讨论了为何刘备刚刚建立蜀汉政权，就遭遇两次惨败？我们知道是因为刘备用不正当的手段夺取了益州，结果让曹操有机会统一了北方，之后在汉中争夺战中，不得不让关羽牵制曹操后方，才让孙权有了可乘之机。刘备这两次兵败都是因为他在益州问题上太过工于心计，缺少正义造成的。 之后我们讨论了对促成三足鼎立局面起决定作用的孙权为何会被忽视？我们知道孙权并不是没有雄心，只是他对欲望有很强的控制力。之所以孙权在三国中的重要性会被忽视，是因为他把自己的野心隐藏起来，等待时机。 接着我们讨论了如何评价曹操的功过？曹操做的最大的坏事莫过于挟天子以令诸侯了，我们总是为曹操扣上一顶汉贼的帽子。相反，他却做了很多别人没做过的好事。官渡之战，他敢以一己之力，向当时社会最顶层的腐朽士族提出挑战，而且在极为艰难的条件下取得胜利，这是一般人做不到的。之后他对北方的统一，更是帮助北方暂时脱离了以袁绍为代表的腐朽士族的压迫，让百姓不用因为战乱到处迁徙，可以安心生产，使得生产力得到恢复，经济也开始复苏。这都是当时别人做不到的好事。而且北方的统一客观上也给后来晋朝能统一全国，提供了物质和经济基础，就这点而言，曹操是最大限度地完成了他的历史使命。 最后我们讨论了如何从现在的视角评价历史人物？在我们能做的这为数不多的评论中，却多少可以看到一点历史的真相。 其实，三国这个时代如果真要是放在中国3500年的文明史中，并不显眼，只是魏晋南北朝400年动乱的一个序幕，但是这个并不显眼的历史时期中，却演绎了无数广为流传的故事，也出现了众多让人憧憬的人物形象。我们敬佩义薄云天的关羽、倾慕雄姿英发的周瑜、更羡慕受刘备三顾之礼的诸葛亮。不过我们也知道，这些人并不完美，他们也都是一个个矛盾的个体，但正因为这样，这些人又显得很真实，似乎离我们并不遥远。所以人们才会在三国时期的英雄身上找到自己情感的寄托。特别是《三国演义》，不就寄托着我们对忠义的推崇吗？也因此三国时期的故事才能一直流传至今，经久不衰。","categories":[],"tags":[{"name":"tip","slug":"tip","permalink":"http://jinzhan.github.io/tags/tip/"}]},{"title":"同治中兴","slug":"2018/同治中兴","date":"2018-10-12T14:33:02.000Z","updated":"2018-11-25T17:05:12.570Z","comments":true,"path":"10/12/2018/同治中兴/","link":"","permalink":"http://jinzhan.github.io/10/12/2018/同治中兴/","excerpt":"","text":"关于作者这本书的作者是已故的美国教授芮玛丽女士，她是美国研究中国近现代史的权威专家，历史学博士，也是著名汉学家费正清的得意弟子之一，曾经任教于耶鲁大学。 关于本书这本书是在上世纪50年代出版的，一出版就在美苏中三国学术界引起了强烈的反响和争议，可以说小小一本书惊动了三大国。本书推出后不久就成了美国大学里主修中国历史的大学生和研究生的必读参考书，这体现了这本书在美国学界的地位。 核心内容本书作者认为，晚清同治朝的一系列改革举措，恢复了国内稳定，开创了中国最早的工业，帮助清朝实现了“中兴”。然而由于“同治中兴”的指导思想仍然是中国传统的政治理念，没有在现代的法律、金融、外贸、工业、教育等方面进行改革，因此，同治中兴不是一次现代化改革，而是一次向过去寻求智慧的复古运动。这种基因，最终决定了它的失败。 晚清的“同治中兴”，是中国政治精英试图借助传统的政治、文化、道德理念，来挽救清朝的一次努力，但由于这种路径的先天不足，同治中兴失败了。 《同治中兴》这本书是在20世纪50年代出版的，一出版就在国际范围内引起了很大的争议。因为在当时的冷战背景下，美苏两大集团不光是在政治上对峙，在一些学术问题上也是相互对立，这本书里讲到一些沙俄欺负清政府的历史，同时又对美国给了很多正面评价，这就引起苏联方面的强烈不满。另外这本书肯定曾国藩、恭亲王奕䜣这些晚清重臣，对太平天国持否定态度，这种的历史观跟当时中国学界的主流立场也比较有冲突，所以中国学界对这本书也有很多的不认同。可以说，小小一本书，惊动了中美苏三大国。 而这本书的地位，也不光是当时特殊的历史背景造成的，单纯从学术角度来看，它也是美国对中国历史研究领域的一本重要著作。举个例子，这本书推出后不久就成了美国大学里主修中国历史的大学生和研究生的必读参考书，这体现了这本书在美国学界的地位。而在今天，时代背景跟当年已经完全不同了，我们也更能够从单纯的历史角度，专注于本书的内容。这本书的主题是晚清的“同治中兴”，作者对同治中兴有一个很有意思的定性：中国保守主义的最后抵抗。也就是说，她认为同治中兴是中国士大夫阶层依靠着传统的政治、文化理念，试图实现救国的一次尝试，也是最后的尝试。因为之后无论是改良路线还是革命路线，这背后的理念，都吸收了很多的外国思想。用这个角度来看同治一朝的历史，我们关注的就不是慈禧太后、同治皇帝、曾国藩这些人物或真或假的历史轶闻，而是能上升到清末以来中国政治和思想走向的高度，对历史有更高更新的认识。这就是这本书在同题材书当中的独到之处，也是我们讲这本书的意义之所在。 下面就进入正题，我们分五个部分来讲：第一，同治中兴是怎么回事；第二，同治中兴是怎么实现的，有哪些内部和外部的条件；第三，同治中兴取得了什么成就；第四，同治中兴为什么最终没能让清王朝摆脱灭亡的命运，它的失败，主要是败在哪些方面；第五，这本书如何评价同治中兴，作者为什么说它是“中国保守主义的最后抵抗”。 第一部分我们先来说说第一个问题，所谓同治中兴，究竟是怎么回事。要说“同治中兴”，那得从同治之前，也就是咸丰朝说起。在咸丰末期，清朝的局势可以说是糟得不能再糟了：1860年，第二次鸦片战争中，英法联军打进北京，烧了圆明园，咸丰皇帝狼狈逃往热河；与此同时，在清朝税赋的主要来源江南地区，也正经历着太平天国运动；同年10月底，清政府被迫跟英法俄分别签了《北京条约》，割地赔款，特别是沙俄，割占了中国东北大片的土地。1861年8月22日，咸丰皇帝郁郁而终，六岁的儿子载淳继位，就是后来的同治皇帝。载淳的年号本来不叫同治，咸丰皇帝驾崩的时候，大臣们拟定的新年号叫“祺祥”，准备第二年改元。但是这个年号还没来得及用，慈禧太后就联合咸丰的弟弟恭亲王奕䜣，也就是著名的“鬼子六”，发动了一场政变，干掉了咸丰临终指定的辅政大臣肃顺等人。这场政变就被称为“祺祥政变”，也叫“辛酉政变”，因为1861年这一年是农历辛酉年。之后，慈禧太后接受大臣建议，改元为“同治”。据说她之所以选择这个年号，是因为它暗喻两宫皇太后“共同治理”。就这样，祺祥这个年号还没来得及使用就被废弃了，1862年就成了同治元年。从当时国内国际的局势来看，好像清王朝马上就要玩完了，然而同治一朝，竟然对内平定了太平天国等四场运动，对外跟列强的关系也缓和下来，并且还建立了一些早期的近代工业，政治上也出现一定程度的开明，国力和民生都有所回升。这个势头，基本贯穿同治一朝，也就是1862年到1874年，这就是所谓同治中兴。中兴，意思是衰落之后再度兴起。中国有句古话叫“一姓不再兴”，姓氏的姓，一姓就指一个朝代，因为一个朝代的君王一般都姓同一个姓。这句话就是说一个王朝衰落之后，就很难再复兴了。所以，“中兴”这种事是相当罕见的，中国几千年也就发生过这么几回。像周朝的“宣王中兴”、汉朝的“光武中兴”，后来唐朝中后期也有所谓“肃宗中兴”“元和中兴”，南宋开国时候也号称中兴。不过这些多是名不副实，后世也有很大争议。 第二部分“同治中兴”这个说法，本身就是对同治一朝的高度肯定，至于说这个中兴到底是不是名副其实，我们该怎样评价这段历史，我们最后再来探讨。接下来先看一看第二个问题：同治中兴的局面是怎么形成的。 关于这个问题，作者总结了四点原因，其中两个是国内的，两个是国际方面的。 国内的分别是：一个精明的、有一定现代视野和自由度的文官政府的建立，以及满汉矛盾的趋缓；国际方面的则是：列强调整对华立场，以及中国的文化吸引了一些对中国亲善的外国人。下面我们逐一来讲讲。 受到一些影视文艺作品的影响，可能很多人印象中，咸丰一死慈禧太后就大权独揽了，其实不是这样。在同治朝初期，同治皇帝年幼，两宫太后的权力相互制衡，慈禧直到1865年才逐步掌握最高权力，再之后又经过大约十年，慈禧才获得独裁地位。而所谓同治中兴，主要就是在这个时间段。 在这期间，清朝事实上是由恭亲王奕䜣为首的文官政府来掌控的，他们的特点是精明强干、视野开阔。虽然他们还是传统官僚，未必有多少现代性，但第二次鸦片战争的惨痛教训给他们留下了足够的警醒。同时，辛酉政变中咸丰留下的满族重臣被大量清洗，也为当时的贤才上升腾出了空间。这样的形势下，同治年间的文官体制对外更慎重，处理内部问题时，则多了一些弹性和灵活。文官体制还恢复了天下士人对朝廷的期望，特别是饱受战火的江南才子们，在战火平息后又能参加科举了，这样一来，同治朝的社会凝聚力因此也得到了部分恢复。 另一方面，内外危机还意外地让清朝的满汉之别得到了缓和。其实在咸丰朝，清朝早期制定的满族优先政策就已经后继乏力了，曾国藩、左宗棠这些汉族重臣，在咸丰朝就得到重用，连保守的满族大臣肃顺，也认为需要授予能干的汉人更大的权力。从咸丰朝末期到同治一朝，像“禁止汉人移民东北”“科举中满族考生用满文答卷”“旗人的一些法律特权”这些以往造成满汉隔阂的政策，都大大放松甚至废止了，可以说除了八旗制和满汉不通婚这两条没变，其他的满汉界线基本消除。 这种满汉融合的步伐，直到1898年戊戌变法失败后才停下来。这样民族界线模糊的局面创造了一种满汉上层和士人共治天下的图景，虽然血统上有差异，但在文化意义上，满汉上层成了维护中国法统、名教的盟友。 除了这些内因，还有外部的原因，首先是西方列强对清朝的所谓“好感时刻”到来了。 从第一次鸦片战争中西方开始正面接触之后，列强特别是英国，对清政府非常看不上，比如发动了两次鸦片战争的英国首相巴麦尊。我们常听说一句话，“没有永恒的朋友只有永恒的利益”，很多人说是丘吉尔说的，其实真正的出处就是这位巴麦尊。 直到1857年他还宣称，“清政府不是一个合法的主权国家”，但是第二次鸦片战争之后，英国人明白过来了，要是不承认清政府，那他们和清政府签订的那些不平等条约，从法理上说也就站不住脚了。所以他们认识到，要承认并且维护清政府，因为这就是维护他们各自在华的利益，所以对清朝的态度有所缓和。 出于这样的考量，对于同治年间，民间的中英冲突，英国采取了相对克制的态度。书里举了个例子，1869年，台南的民众捣毁了英国人在当地的教堂，英国驻台的代理领事吉必勋和一名下级海军军官使用了武力，结果英国的处理是：降了吉必勋的职，归还了索取的赔偿。英国是当时的头号列强，他们的态度也带动了法俄美这些国家，它们也都认识到，支持清廷更有利可图。 同时，随着一些外国外交官深入了解中国，为中国文化着迷，也出现了一些外籍的中国利益维护者。其中典型的代表有威妥玛、卫三畏、赫德和蒲安臣，西方的对华强硬派媒体曾经点名批评他们是“比大沽口炮台更能有效抵御西方文明的四角堡垒”。 威妥玛同治年间任英国驻华全权公使，发明了以拉丁字母为基础的汉语拼读方法“威妥玛拼音”；卫三畏曾9次代理美国驻华公使，退休后成为是美国第一位职业汉学家；赫德1861年起在上海任职于海关总税务司，掌管晚清海关达半个世纪之久，创建了一整套严格的海关管理制度，1911年去世后被清廷追授太子太保；蒲安臣是美国对华合作政策的代表人物，也是美国共和党的创始人之一。 这些人物的历史评价虽然仍很复杂，但在同治年间他们影响了清廷的政策走向和治理方式，引入了现代政府的一些原素，有时还阻止了西方列强治外法权的滥用。由此也帮助清朝在19世纪中期摇摇欲坠之时勉强站稳了脚跟。 ##第三部分正是这些内因和外因的综合作用，为所谓同治中兴的出现提供了条件。那么，“同治中兴”取得了哪些成绩呢？这就是我们下面要讲的第三个问题。 同治中兴的成绩，主要表现在以下四个方面：1、恢复稳定；2、贤人政治；3、建立近代工业；4、设立新式军队。 首先是恢复了国内的稳定。咸丰到同治这段时间，中国爆发过四次大规模的运动。先是太平天国运动，他们的纲领就是推翻清朝，鼎盛时期太平天国扩展到中国差不多一半的省份。还有杜文秀领导的“平南国”，定都云南大理，也曾经宣告独立。此外就是北方的捻军和陕甘民变。这些变乱，后人根据不同的立场，把它们定性为叛乱或是起义，说法不一，但不论怎样，战争对社会造成了巨大破坏。同治政权采取“剿抚并用”的新方针，最终将它们一一平定。虽然战争造成的巨大破坏在整个清朝都没有完全恢复过来，但国内局势恢复稳定，这是一切的基础。 “同治中兴”的精英们做的第二件修复社稷的大事，是推行“贤人政治”。“同治中兴”的主要推动者，在中央是恭亲王奕訢、先后任军机大臣及总理衙门大臣的瓜尔佳·文祥和沈桂芬等人；在地方的代表人物是曾国藩、左宗棠、李鸿章、胡林翼、骆秉章等人，地方的这些重要人物后来也进入中央。其中最有样本意义的就是曾国藩，从他留下的家书和奏折中可以看到，曾国藩广泛论述了他对公共事务的看法，包括军队改革、农业复兴、道德、对外、工业化、教育、财税等方方面面。他的这些看法和思想，统统是儒家视角，使用的是儒家词汇，行动依照的是儒家标准。 这不是他一个人的特点，而是同治重臣们的普遍共性，儒学哲学起到了贯穿、统一他们思想和行动的纲领作用。也就是说，同治中兴依托的思想资源，是儒家哲学这一最传统的思想，同治朝的国家决策层还是寄希望于师法于传统和祖辈的智慧，注意，这就是为什么这本书的书名，把同治中兴称为“中国保守势力最后的抵抗”。 此外，同治朝在江南恢复了因为太平天国而停滞了十多年的科举，在考试上也引入了一些时政策论方面的题目，更注重培养有真正治世才干的人。比如清末的名臣张之洞就是因为在1863年的殿试中，对于太平天国等现实问题回答出色，而受到赞赏的。 同治朝还在限制卖官鬻爵、淘汰不合格官吏、严肃法纪等方面做出过努力。最典型的事件就是，同治八年，也就是公元1869年，山东巡抚丁宝桢杀了违法乱纪的慈禧红人，大太监安德海，而他的仕途未受影响。这部分说明了同治朝吏治整顿是相当严肃的事，而政府的主要官员，也有较大的自由裁量权。 第三件大事就是建立工业和新的财政来源。因为当时的中国还是农业社会，所以同治名臣们首先重振了农业，来作为经济基础，比如安置流民，低价售卖或是租赁土地、种子，减免赋税等等。另外，在战争中清政府终于认识到了工业的重要性，他们尝试了建立近代工业，这也就是我们熟悉的“洋务运动”。中国的第一家航运企业“轮船招商局”出现，中国第一次尝试现代的采矿业、铁路运输、电报通讯，都是在这一时段。 第四件大事，是同治朝官员们建立了新军以及配套的军工业，这也是所有改革项目当中，他们最感兴趣的部分。在这个过程中，其实清朝决策层面临的是非常大的矛盾，一方面作为传统的中央武装力量的八旗和绿营早就腐化，没有战斗力了，不足以应对国内外的军事需求。但另一方面，如果依赖镇压太平天国过程中壮大起来的地方武装，又恐怕会出现唐末藩镇割据那样的局面，地方大员会拥兵自重。幸运的是，曾国藩、李鸿章这些军权在握的人，并没打算另立山头，随着战争的减少，曾国藩的湘军等地方武装主动裁军，这种局面让朝廷有信心编练新军，尝试军事改革。 1865年夏天，长江水师成立，包括800名军官和1.2万名士兵，成为当时东亚最强的海军。同年江南制造局成立，在这里工作的工人薪水是当时农民的4到8倍，实行每天8小时工作制。1868年，江南制造局建造的现代型炮舰下水，随后，时任闽浙总督的左宗棠建立福州船政局。船政局附属学校开授工程技术、驾驶、法语、英语、化学、冶炼、国际法等现代课程，培养出了严复这类的杰出人才。同治朝还聘请了一批外国人直接担任军官，其中比较有名的像我们在历史课本里看到的华尔、戈登，以及他们指挥的“洋枪队”。 不过同治朝廷从没放松过对他们的警惧，朝廷专门为这些人设计了“双龙宝星”的勋章，看上去很荣耀，但其实并不在正式的国家军功体系当中，这样，就防止了他们的军衔提升过快、权力扩张过大。 综上，我们再来重复一下“同治中兴”的主要成就，表现在四个方面：恢复稳定，贤人政治，建立近代工业，设立新式军队。 那么这些努力的成果如何呢？我们可以说，至少在当时看来还是比较令人瞩目的，曾在清朝任职的德国军官日意格在1872年写道：中国正在迅速成为一个令人生畏的对手。英国的《泰晤士报》在一篇评论中兴成就的文章中承认了这一观点。事实上，这些成就作为同治中兴的遗产，在中法战争和甲午战争中，也保证了中方在硬件方面至少没有落后太多，本书作者甚至认为中方在这两场战中投入的现代型武器比对手更多。至于战争胜败，主要是更基础的政治和社会因素决定的。 另外在外交上，清廷在学着适应西方游戏规则同时，仍然艰难地维持着中国主导的朝贡体系，像越南、朝鲜这些从前的朝贡国，在这个时期又开始向北京派遣使者了。当时的外国观察家对此大为惊讶，他们评论说：这些朝贡国是在“继续崇拜中国的影子”。 第四部分前面说了同治中兴的主要成绩，确实，它成就了中国历史上的许多个“第一次”，尤其考虑到这种成就是在咸丰朝内外交困的烂摊子基础上实现的，确实可以说，是难能可贵。然而，我们都知道，同治朝所谓的中兴，最终没能让清朝免于灭亡，在甲午战争中跟同时期开始维新的日本正面对抗，更是一败涂地。那么这又是为什么呢？同治中兴的表象之下，隐藏着哪些导致未来失败的隐忧呢？ 这就是我们下面要讲的第四个问题，也是这本书和这段历史最值得我们思考的问题：同治中兴为什么最终会失败？又是什么因素阻止了中国社会向近代化、现代化的转型？ 前面交代了，同治朝，是从1862年到1874年，但是所谓同治中兴这个历史阶段，并不跟同治朝的起止完全吻合。在这里，作者探讨了她眼中“同治中兴”落幕的标志性事件，那就是1870年的天津教案。 事情的经过是这样的：1858年《天津条约》签订后，很多外国人居住在天津，他们的传教，以及一些不法行为，跟当地中国居民一直有摩擦，大家相互看不顺眼。当时，在天津的法国传教士建立了育婴堂，育婴就是养育婴儿，主要是收养弃婴，而由于他们会给送来婴儿的人一笔钱，这就被理解为买婴儿，这也确实变相鼓励了拐骗婴儿的行为，民间一直对他们这种行为很有非议，甚至传言，育婴堂吃婴儿的传言。 6月19日，迫于民间压力，天津道台约见法国领事丰大业要求搜查教堂，第二天，主管神机营的天津最高长官崇厚亲自介入。当双方准备向上汇报的时候，当地道台、知县等人再次要求进入教堂，傲慢的丰大业在秘书陪同下闯进了崇厚的官邸，向崇厚连发两枪。官邸外面的地方官、士绅、民众随后围住了丰大业，丰大业开枪打死了其中一人。愤怒的人群当即杀死了丰大业和他的秘书。之后又烧毁了法国领事馆，冲进教堂、育婴堂杀死10名法国修女、2名法国神父、7名各国侨民和一些中国教民。 就这样，仅仅一个下午的时间，总理事务衙门和列强苦心经营的“蜜月期”就结束了。消息传回欧洲后，对华开战的声音再次响起，虽然在当时的直隶总督曾国藩等人的勉力维持下，最终仗没打起来，但是，这一下中国在列强以及西方民众眼中的印象分，一下就降到谷底了，之前对实现“同治中兴”非常重要的宽松的外部环境，逐渐就丧失了。此后，随着中兴名臣中曾国藩1872年去世，瓜尔佳·文祥1876年去世，以及恭亲王奕欣受到慈禧的猜忌和排挤，同治时期的文官体制其实已只剩下残影。 严格地讲，天津教案和中兴名臣们的谢幕，只是“同治中兴”落幕的象征，同治中兴并不存在一个精确的截止时间点。但后来洋务运动、戊戌变法的失败确实在“同治中兴”期间就已经初露端倪。“同治中兴”的基因中，带有天然的致命缺陷。从本书当中，我们可以归纳出六点。 第一，也是最重要的，是固守以“礼”为核心的习惯法，而没有建立有助社会转型的法律体系。 这个观点，再次呼应了本书的书名，“中国保守势力最后的抵抗”。在作者看来，中兴名臣们试图采用的，还是在过去几千年中维持中国运转的“礼教”，以“礼”来作为法。换句话说，他们只想修复一个以“礼”来作为运转法则的旧式的社会，而没有想到也没有尝试，建立一个以“法”为基础的新式的社会。这种认识和追求，就注定了同治中兴有太多无法逾越的局限。比如说，“同治中兴”的精英们虽然尊农重农，但并没有发展到解决土地所有权的问题。 同样，出于固守“礼”的使命感，他们从没打算打破社会等级秩序，让社会新生力量参与到中兴事业上来，相反是极力维护原有等级，原有价值观。这种思想最直接的表现，就是沿袭传统的“重农抑商”观念，这点其实从近年来的影视作品中我们就能感受到。无论是早些年的《胡雪岩》《乔家大院》还是前不久热播的《那年花开月正圆》，从中我们都能看到，晚清的商人，任你富可敌国，在权贵主导的政治秩序面前，还是毫无还手之力，所以他们的财富和智慧没法发挥充分的作用，来影响社会的发展。而反观欧洲和日本的商人，在社会转型期，堪称推动社会进步的主要力量。 第二，是滞后的财税金融体制没有跟进，没有催化出新的金融业。 比如，清朝后期，海关收入对清朝财政以及格式举足轻重，但是对于现代化的海关对国家财政的重要性，即使中兴重臣文祥也缺乏基本认识。他跟赫德的一段对话很有代表性，他对赫德说：“如果你们外国人回到自己的国家，还我们以平静生活，我们愿意把你们带给我们的所有海关增收都给你们。”从中我们可以看出，即便时文祥这样的同治朝政治精英，在接触了新的金融机制之后，也没有意识到参照这个模式改造帝国金融，是富国强兵的关键，而是不惜放弃这部分收入，也宁愿回到闭关锁国时代的所谓宁静之中。 第三，是认识不到对外贸易的必要性。 乾隆皇帝虽然喜欢来自西洋的新鲜玩意儿，但从根本上，把这些视为一种奇技淫巧无用之物，而到了同治时代，政治精英们对新鲜事物的认识可以说并没超出乾隆的水平。比如负责对外贸易的名臣刘坤一就曾经表示，外贸对中国制造业是一种危害，因为会挤占中国产品的市场。 第四，与近代化相适应的新学体系没有发展起来。 虽然同文馆、天文算术馆建立了起来，但是，近代化教育并没有普及到基层，全民教育体系更是谈不上。即使是有机会进入同文馆的贵族子弟，他们学习新学，也更重视自己的旧学修养，因为这些旧学，更有利于他们的仕途。 第五，是在近代化进程中自缚手脚，顾虑太多。 恭亲王承认铁路的潜力，但同时担心，一旦铁路修通，成千上万的失去传统生计的人将丢掉饭碗。同文馆对翻译外国科技著作充满热情，但又唯恐这些新的思想观念动摇传统、动摇清朝的统治基础，因此大量的译著，翻译完之后就被束之高阁，而没有真正投入到应用领域。后来这些中国翻译、编写的书籍，都被日本的维新派视如珍宝。 第六，是同治时期短暂出现的文官体制，最终在慈禧重新确立独裁体制后寿终正寝。 随着慈禧权力的不断扩大，曾经在同治中兴中发挥重要作用的文官政府也时断时续，恭亲王奕欣的宦海沉浮，就是最佳的样本。他几起几落，手里的权力不断缩小，也越来越无所作为，最终1884年中法战争，以恭亲王为首的军机处被勒令全体下岗，这就是清史上著名的“甲申易枢”。之后，国事更加不振，“同治中兴”短暂出现的兴旺气象荡然无存。 第五部分以上这六点，就是我们从本书中总结出的，同治中兴失败的六点原因。说完这部分，我们就剩下最后一个问题：为什么作者把同治中兴称为“中国保守势力最后的抵抗”。 其实这个答案就在作者对同治中兴失败原因的分析中。我们可以总结成一句话，那就是，当遭逢晚清种种“三千年未有之大变局”的时候，中国的决策层虽然认识到了要采取重大的变革来应对危机，但是他们没有找准变革的方向，出于种种原因，他们选择从过往的经验中寻求出路，希望借用传统的儒家意识形态和制度，让它在新的历史条件下继续发挥作用，应对危机。 所以作者说，在意识形态上，“同治中兴”不是一次思想解放运动，而是一次全面复古运动。在这个思想指导下，同治时代的各项改革，也就只停留在技术上，而没有推向纵深领域。这些基因里的不足，加上国内的腐败、民族隔阂等顽疾，国外的列强的觊觎，种种因素最终决定了“同治中兴”的悲剧命运：它既是传统的中国保守主义者面对西方的最后一次顽强抵抗，也是近代以来，中国现代化进程的第一次夭折。 总结到这里，《同治中兴》这本书的全部内容就为你说完了。在这期音频中，我们分别从5个方面剖析了这本书的核心内容。首先，我们介绍了“同治中兴”的基本概况；然后分析了同治中兴得以实现的国内和国际条件，其中国内的条件是：一个精明的、有一定现代视野和自由度的文官政府的建立，以及满汉矛盾的趋缓；而国际方面的条件则是：列强调整对华立场，以及中国的文化吸引了一些对中国亲善的外国人。 接着，我们说了同治中兴取得的四项主要成就成就，那就是1、恢复稳定，2、贤人政治，3、建立近代工业，4、设立新式军队。我们还总结了同治中兴最终失败的6点原因。 最后，我们也提到了作者对同治中兴的认识与评价，为什么说这是“中国保守势力最后的抵抗”。","categories":[],"tags":[{"name":"tip","slug":"tip","permalink":"http://jinzhan.github.io/tags/tip/"}]},{"title":"格鲁夫给经理人的第一课","slug":"2018/格鲁夫给经理人的第一课","date":"2018-08-22T14:31:28.000Z","updated":"2018-11-25T16:26:13.758Z","comments":true,"path":"08/22/2018/格鲁夫给经理人的第一课/","link":"","permalink":"http://jinzhan.github.io/08/22/2018/格鲁夫给经理人的第一课/","excerpt":"","text":"关于作者安迪·格鲁夫，英特尔公司的创始人兼 CEO。在他的带领下，英特尔公司多次成功转型，从一家濒临倒闭的存储器公司，发展成为全球大型半导体企业及计算机 CPU 制造商。 作为一位拥有多项半导体技术专利的科学家，格鲁夫的管理理念带有深厚的技术色彩。除了活跃在企业管理的第一线，他还担任了哈佛大学的荣誉教授，长期在斯坦福大学商学院主讲策略管理课程。1997年，格鲁夫被《时代》杂志评为“年度风云人物”。 关于本书本书是格鲁夫对英特尔公司数十年的管理实战经验的总结，也是一位工程技术人才管理经验的实例教案。通过格鲁夫的分享，我们看到了中层管理者作为一个组织的中流砥柱，是如何通过产出导向、团队意识、绩效考核等不同的管理技巧，以有效的投入获得最大的产出。此书受到了《纽约时报》、《华尔街日报》等媒体的强力推荐。 核心内容中层管理者以有效的投入提高产能、获得高产出的三个关键词： 第一，产出导向。中层管理者的一切管理活动，都要围绕整个团队的产出最大化来进行。为此，这些领导者需要找出那些对事项起决定作用的“限制步骤”，并且不断提高自己和整个组织的杠杆率。 第二，团队意识。为了让整个组织能保持持续的创造力和战斗力，通过开会可以让上司和下属建立起共同的信息基础，以及近似的处事方式，形成团队意识，提高工作效率。 第三，绩效考核。好的绩效考核是管理杠杆率最高的行为，中层管理者应该为员工制定竞赛规则，明确未来衡量他们表现的尺度，然后放手让他们去做。 一、产出导向格鲁夫认为，中层管理者的职责就是一切以产出最大化为出发点，想方设法提高整个团队的产能。对于中层管理者来说，他的产出等于他所领导的组织产出的总和。他所从事的每一项管理活动，对整个组织都有或多或少的影响。影响的大小，取决于中层管理者在这项活动中的杠杆率的大小。 杠杆率，是指中层管理者在各个具体的管理活动中，通过自身的管理能力所带来的产出。在作者看来，一个管理活动如果有比较高的杠杆率，就表示同样的投入下，这项活动会比杠杆率低的活动有更高的产出。比如早餐店的服务员，如果能在同样的时间里做好两份早餐，他的杠杆率就比同一时间只能做一份早餐的员工高。 为了提高工作杠杆率，必须找出决定整个生产流程的“限制步骤”，把大部分精力放在这些杠杆率较高的活动上。明确了哪些事情一定要在某个时间做完之后，再把其他相对而言不那么重要的活动穿插进去，从而提高工作效率。 此外，把类似的工作集中在一起做，建立标准化的办事程序，减少花在切换工作场景上的准备时间，也能有效提高工作产出。 二、团队意识格鲁夫认为，一个中层管理者的产出，是他所管理和影响的下属工作的成效总和。要想让整个组织持续地具有创造力和战斗力，通过开会交流意见、达成共识并且进一步形成团队意识非常重要。 在作者看来，开会是有用的，而且是必须的，会议是从事管理工作必须的媒介。中层管理者不可能避免开会，但他们可以让开会这件事变得更有效率。中层管理者工作中很重要的一个部分，是提供信息与技术，把高效、优质的行事方法传授给受他管辖或影响的人。另外，中层管理者还要制定决策，或者帮助别人制定决策。这两种职责，都必须要通过面对面的开会才能更好地履行。 作者建议可以定期召开一对一的会议。这种会议之所以有巨大的杠杆率，是因为它可以让上司和下属在会议上建立起共同的信息基础，以及相似的处事方式。这样一来，整个团队就拥有了共同的意识，指哪儿打哪儿，效率自然也就高了。 三、绩效考核绩效考核作为中层管理者给下属的工作反馈，常常被用来决定对下属的奖励，不管是职务上的升迁、加薪、还是分配股份等其他方式。 通过做绩效考核，一方面可以考察下属的技能水平，看看他是不是缺乏一些技能；另一方面，可以加强激励的力度，好让已经具备适当技能的人能创造出更高的绩效。 作者认为，好的绩效考核是管理杠杆率最高的行为。但是，并不是只有那些大型企业或者组织才需要绩效考核，无论是只有一两个人的工作室还是十几个人的创业公司，只要你在乎运营的效果，绩效考核就必不可少。 中层管理者如果想提高团队的绩效，第一步是训练提升下属的知识和技能，第二步是让“自我实现”成为每一位下属工作的动力。只有这样，他们才会自发地去解决工作中的问题，工作动力才能源源不绝。为此，中层管理者需要做的是站在下属的立场看待下属的工作，引入竞技精神，帮他设定衡量指标，找好对手并制定跑道，下属很自然地就会在这个跑道上自我驱动，不断向前。 绩效考核虽然很重要，但也要讲究灵活性。即使下属没有达成当初设定的目标，他的绩效考核仍然有可能被评为卓越。目标管理的用意，是让人能够按照设定的进度做事，但它并不是决定奖惩的标准。如果上司只是用目标管理来决定下属的功过得失，以至于下属只专注在制定好的目标，而错失了其他更好的可能，往往会造成“只见树木、不见森林”的后果。 金句 提高产能的一个重要的方法，就是先找出具有较高杠杆率的“限制步骤”，然后再把大部分的精力放在这些活动上。 建立标准化的办事程序，化“不规律”为“规律”，建立起处理问题的固定模式，是提高工作产出的一种重要方式。 一对一的会议之所以有巨大的杠杆率，是因为它可以让上司和下属在会议上建立起共同的信息基础，以及相似的处事方式。 如果上司只是用目标管理来决定下属的功过得失，以至于下属只专注在制定好的目标，而错失了其他更好的可能，往往会造成“只见树木、不见森林”的后果。 把办公室变成竞技场，能培养下属的“运动员精神”。求胜但不怕输，随时向自己的极限挑战，这是一个团队能不断前进的主要动力。","categories":[],"tags":[{"name":"tip","slug":"tip","permalink":"http://jinzhan.github.io/tags/tip/"}]},{"title":"永远幸福的科学","slug":"2018/永远幸福的科学","date":"2018-05-27T14:41:09.000Z","updated":"2018-11-25T16:26:08.394Z","comments":true,"path":"05/27/2018/永远幸福的科学/","link":"","permalink":"http://jinzhan.github.io/05/27/2018/永远幸福的科学/","excerpt":"","text":"关于作者泰·田代是美国马里兰大学情感、性格以及成瘾症研究中心的资深研究员，探索传播公司旗下美体健康频道的情感专家。他曾获得明尼苏达大学心理学博士学位，在马里兰大学以及科罗拉多大学获得年度优秀教授荣誉。他的研究成果已在多种世界学术期刊上发表。作为恋爱问题的专家，泰·田代博士对如何保持持久恋爱方面有独特研究见解。 关于本书本书通过深入科学研究，从生活中的真实案例着手，提出了寻找持久爱情的方法。我们能够根据本书提供的方法看懂自己的伴侣，也能够在它的指导下找到让自己幸福的另一半。了解了他的研究心得，你就会明白什么样的夫妻会幸福恩爱一辈子，而哪些人并不适合成为理想伴侣；我们自己的性格属于哪种依赖模式，什么性格的伴侣更容易出轨。 核心内容每个人有不同的特质，而这个特质是很难改变的。心理学家把人的依赖模式分为三种：安全型、回避型和焦虑型。对你的伴侣多考察一段时间，等对方的特质彻底表现出来之后，再去判断对方才会更加准确和可靠。一旦发现伴侣身上表现出的危险信号，应该立即做出科学应对；永远不要自欺欺人，让自己在错误的选择上越走越远。 点击查看大图，保存到手机，也可以分享到朋友圈 一、特质的属性及其预测功能 特质是指人身上独有和固有的品性 能力方面的特质包括迟钝还是聪明。性格方面的特质包括内向还是外向，刻薄还是友善，无聊还是有趣，做事认真还是马虎。外貌方面的特质包括高矮、胖瘦、普通或迷人。价值观方面的特质包括宗教信仰、政治取向。总的来说，可以被归为特质的因素范围很广。 特质具有稳定性 特质一方面是从父母那里遗传来的，另一方面是由我们成长的家庭和之后的环境造就的。这些都会使我们的特质难以改变。 特质是预测未来状况的利器 婚前的慎重选择很重要，避免看错人的最好的办法就是，多考察一段时间，等对方的特质充分、彻底地表现出来之后，利用你掌握的利器，再判断一下他会不会带给你永远的幸福。 二、寻找一个拥有合适特质的人 理想的伴侣需要的特质是因人而异的 构成一个人的特质有很多，你需要把你心目中的理想伴侣的特质排出顺序，把你认为能够保证恋情长久的必需条件放在前面。 只能许三个愿望 我们只能许三个愿望，要合理地分配三个愿望。合理的分配指的是三个愿望中可能有的绝对不能更改，其他的稍微有些放宽的余地。 过度挑剔会适得其反 你的条件越多，选择的余地越小，而且条件有时还需要调整，因为有人一开始并不知道自己想要什么。 两种非理想伴侣 一种是神经敏感的人，一种是猎奇心重的人。神经敏感的人是指安全感差、疑神疑鬼的人。猎奇心重的人是指喜欢追求新鲜刺激、不愿意简单重复的人。 5.宜人性强的人适合做理想的伴侣 宜人性强的人，不仅更为友善，更亲切体贴，而且更有可能在恋爱关系中做出努力，让对方更满足，使双方的关系持续保鲜。 三、根据不同依赖模式，选择不同伴侣 三种依赖模式 心理学家把依赖模式分为安全型、回避型和焦虑型。安全型的特点是：比较容易和人亲近，也容易依赖他人和被人依赖。回避型正好相反，它的特点是：不适应与他人过于亲近，不大相信别人，也不允许自己去依赖别人。焦虑型的特点是：觉得别人不愿意亲近自己，经常担心伴侣不爱自己或是不愿意和自己在一起。 不同依赖模式的不同表现 安全型的成年人在爱人身边会表现得心情平静。回避型的成年人，有可能从一开始对感情就没有投入很多，他们对工作可能很投入。焦虑型的成年人会紧紧地缠着爱人，生怕失去。 根据不同的依赖模式选择伴侣 研究表明安全型的伴侣能带给你更多的幸福感、恋爱满足感，并且本人在感情中也更容易得到幸福，和他们结合的婚姻也会更稳定。有时人们也会选择和自己的依赖模式相近的人。 四、要能辨别出伴侣身上的危险信号 爱情中的归因法 为事件的出现寻找原因或解释的习性，被心理学家称为“归因。”晚餐约会时你迟到了，而你的伴侣独自一人在餐厅里坐了20分钟等你出现。你的伴侣可以通过四种归因方式解释你的迟到。第一种是他觉得自己没什么价值，你快要离他而去了。这是从自身方面找原因。第二种是他觉得你缺乏责任感，这是从你的角度找原因。第三种是认为你们没有沟通清楚，这是从两个人的关系中找原因。第四种是认为路上堵车，这是从环境方面找原因。第二种，觉得你缺乏责任感，是最有杀伤力的。如果对方在感情中一有争执或一出问题就会归咎到你的身上，这就是一个醒目的危险信号。 要求/退缩沟通模式 伴侣中一方提出要求的时候，并不是在和善地提出要求，而是或多或少带着责备、施压、唠叨和埋怨。用这种方式传递需求，时间一长，伴侣中的另一方也会干脆放弃了探讨问题的努力，主动避免进行任何讨论。 虐心的恋情 它指在一段恋情中，一方因为太爱对方，所以产生强烈的控制欲，经常向对方强加不公。被爱的一方，被爱情折磨得麻木不仁，言听计从，非常痛苦，这是一种畸形的恋爱关系。 谨慎对待伴侣间的危险信号 如果你遇到一个凡事都往你身上推责任，总是带着责备提需求，或者有着强烈的控制欲不公平对待你的人，在有退路的时候尽早离开他。 要多听取家人和亲友的意见 通常来说要在恋爱关系中准确地评判对方的性格，你的朋友和家人才是最有发言权的。 金句： 在婚姻中，不存在所谓的输赢，如果双方在一些事情上有了优劣之分，那么从长远来看，夫妻双方都是失败者。 区别伟大婚姻和美好婚姻的一个因素，便是感激之情，超越容忍之情的程度。 在一段感情上投入了大量时间和精力的人比较容易抓住对方不放。 激烈的情感只是昙花一现，如果把激情作为长久恋情的首要目标，那么我们大多只能得到一些美好的片段和悲情的结局。","categories":[],"tags":[{"name":"tip","slug":"tip","permalink":"http://jinzhan.github.io/tags/tip/"}]},{"title":"坚持,一种可以养成的习惯","slug":"2018/坚持,一种可以养成的习惯","date":"2018-04-12T14:05:12.000Z","updated":"2018-11-25T16:22:22.507Z","comments":true,"path":"04/12/2018/坚持,一种可以养成的习惯/","link":"","permalink":"http://jinzhan.github.io/04/12/2018/坚持,一种可以养成的习惯/","excerpt":"","text":"1234本书和作者本书在日本亚马逊网站上一直是读者五星好评的图书。它从研究人的“行动科学”入手，系统地介绍了培养习惯的阶段性特征和应对方法，告诉你行动坚持不去的真相，并帮助你用正确的方法把坚持变成一种习惯，从而让任何习惯就都能够坚持下去！作者是日本人，古川武士。现为日本习惯培养顾问公司董事长，有多年培训指导企业经营者和职场人士的经验。 本书核心内容独特观点：把“坚持”这件事本身也变成一种习惯，任何习惯就都能培养。 坚持不下去的真相 习惯坚持的三种类型和三个阶段； 坚持下去的其他技巧 坚持不下去的真相1.习惯引力 所谓习惯引力，是指身体保持在固定的状态会感受比较舒适，发生变化则被视为是一种威胁。 每个人都受习惯引力的影响，让身体天然有“对抗新变化、维持现状的倾向”的倾向。 2.习惯引力的两个功能 抵抗新变化：若要将某项行动转化为习惯的话，必须克服习惯引力； 维持现状：一旦突破前一个阶段的习惯引力的阻碍，养成习惯后，大脑就会把这种行为认为是日常功能，就会拼命地维持这种行为。 习惯坚持的三个种类型和三个阶段1.习惯的三种类型 行为习惯：指动动手就可以做到的习惯，比如写日记、整理家务等。一般一个月左右就能养成。 身体习惯：是指要让整个身体发生变化的习惯，比如减肥、早睡早起等。可能需要三个月左右的时间。 思考习惯：指像创意思维、批判性思考能力等习惯。这种习惯养成需要更长时间，可能半年，甚至一年两年才能培养起来。 举例：“21天培养习惯”这个方法为什么有的人适用？有的人不适用？ 2.培养习惯的第一个阶段，反抗期（一般1-7天） 症状：身体抗拒改变，只有三分钟热度 反抗期最容易失败，是因为“习惯引力”在作祟，你想改变可是你的身体在抗拒。 对策一：以“婴儿学步”开始 “婴儿学步”是指像小宝宝学走路那样，从小目标做起。 让要改变的行为对身体的影响尽量减小。跟之前节目《微习惯》中介绍的方法是一样的， 不过本书给了我们全新的启发，微小的习惯培养，更重要的是用在身体反抗期。 比如5分钟整理，阅读15分钟；读两页书，写一页日记等微小习惯做起。 对策二：简单记录 就是把培养习惯的过程刻意地记录下来。 记录其实是调动理性的力量，去消除“随意”的感觉，客观的掌握事实，让自己和身体的习惯引力更有效的做斗争。 比如记录每天读了多少书，减肥期间每天吃了多少食物等等 ###3.培养习惯的第二个阶段，不稳定期（一般8-21天） 度过身体反抗期之后，身体慢慢就接受了这个新习惯，接下来就要提高习惯培养的强度，而这时习惯引力又开始阻碍我们，从而进入第二个阶段。 症状：因各种突发事件导致失败，半途而废。 要度过不稳定期，就要增强身体养成习惯的稳定性，建立能够持续的机制。 对策一：让行为模式化就是把想要培养的习惯尽可能弄成固定的模式，固定时间，固定地点，固定行为。比如读书习惯，固定在每天晚上8点。 对策二：设置例外规则先假设可能发生的例外状况，也就能提前考虑好应对措施，让计划保持弹性。比如加班晚了，在路上听一段《每天听本书》来代替每天8点的读书计划。 对策三：引入奖惩机制进一步从外部的环节来强化前两个对策，“行为模式”和“设定例外规则”，加强对身体 不稳定期的支撑作用。比如实现了连续七天的读书目标，给自己买个礼物奖励自己，如果没达到就罚自己做30个俯卧撑。 4.培养习惯的第三个阶段，倦怠期（一般22-30天）症状：提不起劲，感到厌烦而前功尽弃。 克服倦怠期，需要“玩点新花样”，通过两种方式进行变化 对策一：添加新变化 一件事情重复做，做久了肯定很厌烦，人都有喜新厌旧的毛病。所以要主动给自己添加 变化。 案例：日本著名相扑选手贵乃花，成功减肥的方法。 对策二：计划新习惯 在倦怠期，计划下一项习惯就是为了建立习惯的连贯性，就像通关打游戏一样，提出一 个新目标和新愿景，有助于你把这个习惯坚持下去的。 坚持下去的其他技巧 每次只培养一个习惯，不要同时培养多个习惯，比如运动或者控制饮食选其一，这样成功概率会提高。 习惯的行动规则是越简单越好，把一个复杂的习惯拆成一些简单的习惯来培养，行动越简单才越好坚持。 不要太在意结果，注重习惯培养各个阶段的节奏。 本书金句 习惯就是把重复的行动化为无意识的行动。 一旦大脑认定某种行为跟往常一样，就会拼命地维持这种行为，这也是习惯引力的功能。 培养习惯的过程需要缜密地设计，如果随随便便开始行动，极有可能会因为“习惯引力”的作用而遭到挫败。 在培养习惯的过程中失败率高的人，通常在一开始就失败了。 “0与1”的差别远远大于“100与1”的差别。 一旦建立了固定的行动节奏，身体就能适应“不做不行”的状态。 人是被习惯所塑造的，优异的结果来自于良好的习惯，而非一时的行动。","categories":[],"tags":[{"name":"tip","slug":"tip","permalink":"http://jinzhan.github.io/tags/tip/"}]},{"title":"关键时刻","slug":"2018/关键时刻","date":"2018-03-19T14:22:03.000Z","updated":"2018-11-25T16:22:43.901Z","comments":true,"path":"03/19/2018/关键时刻/","link":"","permalink":"http://jinzhan.github.io/03/19/2018/关键时刻/","excerpt":"","text":"关于本书作者：詹•卡尔森，32岁，当上了瑞典最大的旅行社的CEO，36岁当上了瑞典境内最大的航空公司的CEO，38岁当上了北欧航空公司的CEO。用了一年时间，就把北欧航空公司，从瑞典政府最头疼的亏损大户变成了全球最赚钱的航空公司之一。46岁撰写本书，风靡全球的管理界和企业界。 什么是关键时刻？关键时刻（MOT)—— Moments of truth，用户和公司之间发生了交互关系的瞬间。 案例： 在一年当中，每一个北欧航空的乘客平均每人接触五名员工，会对北欧航空公司产生五次印象，每一次十五秒钟，总共五千万次。而这五千万次的“关键时刻”决定了公司将来的成败。 一、如何把组织结构翻转过来，变成倒金字塔式的组织形态金字塔式：信息自下而上的汇报，命令自上而下的传达。 倒金字塔：掌握“关键时刻”的员工不用一层层请示上级，管理者们的义务是必须想法设法把基层员工需要的资源解决掉。 案例1： 乘客都在抱怨飞机上的咖啡很难喝、面包很难吃。卡尔森把这个问题交给了他们的空乘人员。空姐们提出了解决办法：取消免费的飞机餐和饮料，改为收费的，并且因为有收入，所以可以提高品质，有需求的人更容易对买到的餐食感到满意。 空姐可以在自己的航班上尝试这个办法，如果卖赔了，要承担风险，但是如果赚钱了，公司和乘务组分红。仅此一项，公司就从付出四十万美金的净成本，变成多赚了好几百万美金。空乘人员的收入提高了，服务水准也进一步提高。很快，这个经验就从卖飞机餐，扩展到了在飞机上销售各种特色商品。 案例2： 解决晚点问题的，交给调度中心的一线人员，因为每一次晚点都会影响他们的工作。卡尔森找到调度中心的负责人，他回去写了一份详细的报告，说需要180万美元、六个月。卡尔森直接交给他负责，结果只花了二十万美金、四个多月就把长期以来的顽疾解决。 案例3： 海底捞的服务员，只要他认为有必要，都可以给客人免一个菜或加一个菜，甚至免一餐。 二、如何在企业中做一个沟通者与教育者；那就是人人都在进行决策，意味着你必须保证每个人都真正理解公司的目标和战略，对领导者而言，这将是一个巨大的、永无止境的沟通任务。 卡尔森是这样做的： 强制自己拿出一半的时间，在工作现场与普通员工进行面对面交谈。 训练自己的沟通能力，参与各种电视辩论，在这个过程中，不断打磨自己举例子、做推销、吸引人的能力。 取消了管理层的一切特权。传递一个理念：这家公司要把所有的精力都放在用户身上。 三、如何找到帮助公司实现盈利的那些最有价值的用户。通过观察每架航班的上座率，发现头等舱因为票价太高，经常是坐不满，造成实际损失；经济舱因为必须打折，而赚不到钱。结果就是飞机利用率很低，亏损严重。 卡尔森在旗下所有的航班上，取消头等舱压缩经济舱，取而代之的是介于头等舱和经济舱之间的商务舱。 针对那些公司为他们报销差旅费的商务旅客，打造了一个专属的航空公司。找到了拿些价格最不敏感、需求共性最多的客人。 总结： 《关键时刻》对管理学最大的贡献，是把很多似是而非的管理理念和方法拉下马来，他的实践证明了，管理者只有一件事是绝对正确的，那就是为员工赋能，激活一线。 每个管理者应该基于自己的洞察，找到自己行业所特有的MOT，然后，聚焦全部力量，形成单点突破。 十大关键时刻原则： 创造顾客比创造利润更重要 用提高营业额降低成本 领导少些决策力多些综合力 了解顾客真正需要把握多变市场 一线员工比管理团队更了解企业 该冒险的时候必须勇敢一跳 “沟通 ”能提升执行力与利润率 让董事会了解公司的整体战略 保持绩效评估和顾客需要的一致性 奖励让顾客满意的“自作主张” 金句： “永远不要忘记，要想做成好生意，先得拒绝不好的生意” “足球运动员在射门前不可能先请示教练” “先创造出用户，才能创造出利润” “管理者抱怨的员工的每一个坏毛病都是来自管理者” 今日的管理者既是倾听者，也是沟通者与教育者，他们善于表达自己，鼓励员工发挥最大的潜力，而不是自行制定所有决策。","categories":[],"tags":[{"name":"tip","slug":"tip","permalink":"http://jinzhan.github.io/tags/tip/"}]},{"title":"你充满电了吗？","slug":"2018/你充满电了吗","date":"2018-03-16T15:09:19.000Z","updated":"2018-11-25T16:26:24.891Z","comments":true,"path":"03/16/2018/你充满电了吗/","link":"","permalink":"http://jinzhan.github.io/03/16/2018/你充满电了吗/","excerpt":"","text":"关于作者汤姆·拉思，美国盖洛普公司全球咨询业务负责人，《纽约时报》、《华尔街日报》的人气作者。他在过去的20年中，出版了五本畅销全球的著作，包含《纽约时报》销售冠军《你的桶子有多满》、《盖洛普优势识别器2.0》等。这些作品总销量已经超过600万册。 关于本书在这本书中，作者汲取来自商业、心理学和经济学的实用研究成果，提炼出让你保持精力充沛、提升工作状态的三大关键因素和帮助你快速充电的技巧。 核心内容要让自己精力充沛其实很简单，那就是要重视以下三大关键因素： 创造意义； 积极互动； 储备能量。 一、创造意义 要追求意义而不是追求幸福 研究证明一：一个人如果越看重个人幸福，他在日常生活中就越容易有孤单和无力感。 研究证明二：当一个人过着幸福但缺乏有意义的生活时，他们的身体会激发慢性炎症的发生。 优先考虑意义而不是金钱 我们在做决定的时候，会不由自主地陷入到优先考虑金钱而不是意义的习惯里。而优先考虑金钱，会不知不觉分散我们关注生活意义的注意力。有研究证明，当人想到金钱的时候，会拉开和别人的物理距离，把自己孤立起来。 内在动机激发热情 外在动机：你为了某种回报而去做某件事情，比如为了赚钱而工作。一旦没钱，生活就没意义了。 内在动机：你内心把一件事情做好的愿望，哪怕没有任何金钱回报，你也愿意去做。真正激发我们热情的正是来自内在动机的事情。 在工作中寻找意义 每份工作都有各自的意义，寻找工作能为别人带来的价值，就能让工作有意义，和让自己精力充沛，充满热情。 二、积极互动 80%正面的事情 跟人聊天互动的内容至少有80%是围绕正面的事情。有研究发现，负能量词汇的效果通常是正能量词汇的4倍。如果你想让别人充满精力和斗志地工作，那你就用80%的时间说正面的、积极的内容，20%的时间来提出不足和改进。 花钱买正面互动 121. 不是花钱买具体的东西来满足自我物质欲望，而是花钱买体验。有研究发现，体验消费提供的快乐比人们预估的更多，而且持续的价值也要更高。2. 花钱买体验的关键在于，把钱花在别人身上，和别人一起互动。针对一组有抑郁症的青少年的调查研究发现：选择把钱给家人的青少年，抑郁症状减轻幅度最大；而把钱自己留着的青少年，抑郁症状加剧的概率变得更高。 多表扬别人发自内心地表扬别人，不真诚的表扬其实比批评更有伤害性。 三、储备能量 对压力的误区认为压力有时间限制，过几天就过去了。其实，压力是会积累的，就像滚雪球。要防止压力堆积，并保持充沛精力，保持健康的生活方式很重要。 给身体补充能量 1234创造意义和积极互动两个方法，是给精神充电，而健康的生活方式是给身体充电。1. 吃好：食物的质量比数量要重要。一些食物能为你提供正能量，另一些食物则具有反作用。比如：蔬菜和水果会让人更冷静更快乐，而油炸食物会让人昏昏欲睡。2. 运动：作者提醒一个大多数人没有注意到的问题，那就是天天运动抵消不了长时间坐着给身体带来的危害。3. 睡足：保持充足睡眠是保持精力的重要法宝。 微笑承受哪怕是假笑和被迫笑也能帮助你应对压力。有医学研究证明，在皱眉肌注射肉毒杆菌的参与者，会因为不能愁眉苦脸，有52%的人抑郁症得到了缓解。 金句： 一个人如果越看重个人幸福，他在日常生活中就越容易有孤单和无力感。 金钱和意义，哪个是前提很重要。 负能量词汇的效果通常是正能量词汇的4倍。换句话说，前面80%的积极正面信息，刚好能让别人接受后面20%的消极信息还能心平气和。 能赚钱很棒，但我做事的动力来自创造伟大的产品而不是利润。——乔布斯 财富会导致人们花在喜欢的事情上时间变少，而花在带来压力的事情上的时间变多。——丹尼尔·卡尼曼","categories":[],"tags":[{"name":"tip","slug":"tip","permalink":"http://jinzhan.github.io/tags/tip/"}]},{"title":"Web前端面试题(2017年)","slug":"2017/interview-question","date":"2017-03-20T15:35:09.000Z","updated":"2018-11-25T16:33:42.973Z","comments":true,"path":"03/20/2017/interview-question/","link":"","permalink":"http://jinzhan.github.io/03/20/2017/interview-question/","excerpt":"","text":"前端基础知识 请写下display属性有哪些属性，每个属性的意义 写出常用的CSS选择符，至少5种，并说出他们的优先级 两栏布局，左侧固定右侧自适应，写出所有可以实现的方案 使用css3做一个旋转的动画效果 css如何清除浮动 如何实现响应式布局 删除数组a中值为m的项 js中如何定义一个只读变量、属性 前端有哪些方法可以实现本地的数据储存，有什么区别 怎么用canvas加载一张图片 一个ul下有多个li，点击任意一个alert出其index 使用正则表达式，验证表单中输入的是一个url（尽可能精确），如： 1234提示，网站链接形式：- http://www.baidu.com- https://know.baidu.com/question/33546162633632336435650200/401301- https://www.baidu.com/s?wd=%E7%99%BE%E5%BA%A6%E6%B4%BE&amp;rsv_spt=1&amp;rsv_iqid=0x9741e0c70008a553&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_sug3=9&amp;rsv_sug1=9&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=1629&amp;rsv_sug4=1630&amp;rsv_sug=1 ((a,…b) =&gt; a*b.length)(1, 2, 3, 4, 5)返回值是多少; 写一个方法flatten，将多维数组转化为一维数组： 1234let a1 = [[0, 1], [2, 3], [4, 5]];let a2 = [0, [1, [2, [3, [4, [5]]]]]];flatten(a1) // [0, 1, 2, 3, 4, 5]flatten(a2) // [0, 1, 2, 3, 4, 5] 写出返回值 123let a = function (x, y, z) &#123; return x + 10 * y + 100 * z;&#125;;let b = a.bind(null, 1, 2);b(3, 4, 5); // 求返回值 用js实现冒泡排序 九宫格实现最短路径 | 10 | 9 | 8 ||—-|—-|—-|| 7 | 5 | 9 || 6 | 3 | 2 | 写出Vue生成的HTML结构 12345678910111213141516171819202122232425262728293031323334// html&lt;div id=\"app\"&gt; &lt;hello-world :level=level&gt; &lt;div slot=\"h1\"&gt;Hello Foo&lt;/div&gt; &lt;div slot=\"h2\"&gt;Hello Bar&lt;/div&gt; &lt;/hello-world&gt;&lt;/div&gt;// jsVue.component('hello-world', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, [ this.$slots['h' + this.level], 'Hello World' ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;);new Vue(&#123; el:'#app', data: &#123; level: 2 &#125;,&#125;) 系统知识 为什么 0.1 + 0.2 === 0.3 为 false 怎么画出0.5px的边框，有哪些方案 请解释进程和线程的区别 请解释下js中的事件轮询的机制 请说说你对Vue或React中虚拟dom的理解 浏览器如何判断访问本地缓存还是请求服务器 请至少说出一个你实现的组件，组件功能/参数/调用方式 开放问答最能代表技术的案例？ 前后端怎么配合的？ 负责了哪个部分 其中的技术难点在哪儿 怎么实现的 有哪些技术产出？ 有开源的项目么 有做过技术分享么（组内） 为什么会选择离开当前的团队呢？你当下最关注的技术是什么？未来的职业规划## 自问自答，哈哈哈哈11.1234567891011121314// 1$('ul').click('li', function()&#123; console.log($(this).index());&#125;);// 2var li = document.getElementsByTagName('li');var i = 0;var len = li.length;for(;i&lt;len;i++)&#123; !function(i)&#123; li[i].onclick(function()&#123;alert(i)&#125;); &#125;(i);&#125;14.12345var flatten = function(args)&#123; return args.reduce((prev, current, index, arr) =&gt; &#123; return prev.concat(Array.isArray(current) ? flatten(current) : current); &#125;, []);&#125;;15.1234567891011121314var bubbling = function(arr)&#123; var len = arr.length; var i; while(len--) &#123; for(i = 0;i&lt;len;i++) &#123; if(arr[i] &gt; arr[i+1]) &#123; arr[i] ^= arr[i+1]; arr[i+1] ^= arr[i]; arr[i] ^= arr[i+1]; &#125; &#125; &#125; return arr;&#125;;","categories":[],"tags":[]},{"title":"sed命令中的N","slug":"2016/sed-n","date":"2016-08-03T02:35:09.000Z","updated":"2018-11-25T16:08:34.375Z","comments":true,"path":"08/03/2016/sed-n/","link":"","permalink":"http://jinzhan.github.io/08/03/2016/sed-n/","excerpt":"","text":"背景想把下面一组的uid和wealth弄到同一行，有什么好的实现方式呢？ 123456789101112uid[1025472]wealth[33600]uid[1025472]wealth[33600]uid[1031052]wealth[4800]uid[1031052]wealth[4800]uid[1031697]wealth[4800]uid[1031697]wealth[4800] 答案 1sed 'N;s/\\n//g' w.log 和awk类似，sed语句的基本结构也是 sed ‘模式{动作1;动作2}’ file 的执行方式。不过sed中有两个空间，一个叫pattern space（模式空间），一个叫hold buffer（缓冲区/缓冲空间），sed中的模式匹配的对象只是模式空间，和awk一样，sed也是一行一行的读入文本，不过sed在执行命令前，会将文本的行读到模式空间中，然后执行模式{动作}语句，而在执行命令完后，默认sed还是把模式空间的内容打印出来（通过-n 参数可以把最后默认打印模式空间的动作取消）。 实例1 1234seq 6 | sed -n 'N;P'135 [解析] 这个命令就是输出的奇数行，怎么来实现的呢？首先N的作用是读取下一行内容，追加到模式空间里，那sed是逐行执行的，这时候读取1，N把下一行追加到模式空间，那模式空间里的内容就变成了 1\\n2 虽然是2行，但是这时候sed把2行看做中间有个换行符的一个整体内容，在模式空间里面。然后继续执行命令P，打印第一行内容。那么1就输出到了屏幕上，接着读取3，N追加4，P输出3，这样一直按这个顺序执行，输出了所有奇数行。这个命令是不是很巧妙？ 实例2 123seq 5 | sed -n 'N;P'13 [解析] 输出奇数行？5没有输出。是的，这是为什么呢？可以info sed看看N的解释“If there is no more input then ‘sed’ exits without processing any more commands.”，如果没有可以追加的内容，那么sed将不会处理后面的任何命令。当sed读到5的时候，已经没有下一行内容了，那么N将退出，也不再执行后面的P。所以5没有输出。怎么解决呢？ 1234seq 5 | sed -n '$!N;P'135 [解析] $!N就是N对最后一行不起作用","categories":[],"tags":[{"name":"sed","slug":"sed","permalink":"http://jinzhan.github.io/tags/sed/"}]},{"title":"Texas Holdem Poker Skills","slug":"2016/Top-Five-Texas-Holdem-Poker-Skills","date":"2016-05-25T12:28:28.000Z","updated":"2018-11-25T16:08:34.373Z","comments":true,"path":"05/25/2016/Top-Five-Texas-Holdem-Poker-Skills/","link":"","permalink":"http://jinzhan.github.io/05/25/2016/Top-Five-Texas-Holdem-Poker-Skills/","excerpt":"","text":"Top Five Texas Holdem Poker SkillsWhen you play Texas Holdem poker there are definitely a few skills that you will want to have and others you will always want to work on. Let’s look at each one of these and give you an idea of which ones are the most important. 1. Table SelectionThere may not be anything more important than selecting the right table when it comes to playing Texas Holdem. You can play extremely good poker, but if excellent players surround you, your win rate is going to be less. Conversely, if inexperienced players surround you, your chances of making money are better, even if you make a few mistakes. You can make a great deal of money against bad poker players, but you can lose a lot against the great ones. Picking the softest table may sound gutless, but you would rather be smart in selecting a table you know you can beat. 2. Hand SelectionThe biggest mistake most players make when playing poker is playing too many hands. If you have the discipline only to play strong hands, your chances of making money are much better. Patience is definitely a virtue in poker and waiting for strong hands is a good idea. When you do get the strong hand, make sure and raise accordingly. 3. Reading Opponent’s HandsIt is always important to try and put your opponent on a hand. You are not always going to be right, but if you really work at it, you might be surprised how often you are correct. Every action a player takes gives you information about the hand they hold. You make guesses based on the actions they take. 4. Pot OddsAlways be aware of pot odds. The professional poker player always knows if the odds are worth it. You can count the number of “outs” you have to estimate and decide if calling is a positive play. It is a calculation based on your outs, the money you have to lay out, and the money in the pot. 5. Analyzing Your OpponentYou want to be aware of what you opponent is likely to do. There are the maniacs, the calling station, the tight player, etc. You want to be aware of each of these tendencies in regards to your opponents. The more you can put your opponent on a particular type of player, the better chance you have to predict how they will play. The Gap ConceptYou need a better hand to call a raise with Than you do to make a raise with (For example, if I was first part, I will raise pairs with 9, or I would raise with it rather than call). PositionSee how opponents act before my turn to act. Have the last opportunity to bluff. Extract more money from opponents. Five Reasons to Raise Get more money in pot. Limit the competition. Take control of betting. Make opponents define hands. Steal BLINDS and ANTES. Odds and OutsStep 1 Counting Outs. Step 2 The Rule of 4 &amp; 2. 1234567891011121356s for exampleFlop: Qs3h7sRule of 4:Odds: (9 + 3) * 4 = 48%Turn: 8cRule of 2:(9 + 3 + 3) * 2 = 30% Step 3 Calculating Pot Odds 123Pots: 400Bet: 100Odds: 100/(400 + 100) = 20% Step 4 Make Winning Decisions 1234565 Outs 5 * 4 = 20%Implied Odds Take Time to Think Opponents playing conservatively or aggressively ? What hands are my opponents likely to hold ? What do my opponents think I have ? Am I in good position or bad position ? Should I bet or raise ? 1234567891011Best hand?Bet or RaiseForce weakopponents out?Should I check or fold?Worst hand ?check or fold Take Time Out After Significant Changes How has my image changed? Who may be on tilt? should I change gears? Common MistakesBad players make the same mistakes over and over. Poker players who exploit bad players and their mistakes will win. Common Mistakes They don’t bluff enough. They over-value top pair. They don’t bet enough. They call too much instead of folding or raising. They play too timidly. They telegraph the strength of their hand with tells. They go on tilt. Steal the Blinds No bad beats. No big suck outs. No big desisions. strategy Target the Average Stacks. Average Stacks can afford to fold. Big Stacks are likely to call because they can afford to take risk. Small Stacks are likely to call because they’re desperate. Bluffs My opponent believes I’m playing tight. My opponent hasn’t witnessed a bluff from me recently. My opponent isn’t likely to have a great hand or a great draw. My hand can’t win without a bet. My oppenent isn’t anywhere near pot committed. My oppenent is likely to think the last card helped me. Bluffing effectively is a part of Selective Aggression. Pick your spots carefully then play them aggressively. Make the Big Laydown","categories":[],"tags":[{"name":"Poker","slug":"Poker","permalink":"http://jinzhan.github.io/tags/Poker/"}]},{"title":"Code Complete笔记","slug":"2016/summary-of-code-complete","date":"2016-04-23T14:15:08.000Z","updated":"2018-11-25T16:08:34.375Z","comments":true,"path":"04/23/2016/summary-of-code-complete/","link":"","permalink":"http://jinzhan.github.io/04/23/2016/summary-of-code-complete/","excerpt":"","text":"软件构建 What is software construction 定义问题 (Problem Definition) 需求分析 (Requiremnets Development) 规划构建 (Construction Planning) 软件架构 (Software Architecture)，或高层设计(High-Level Design) 详细设计 (Detailed Design) 编码与调试 (Coding and Debugging) 单元测试 (Unit Testing) 集成测试 (Integration Testing) 集成 (Integration) 系统测试 (System Testing) 保障维护 (Corrective Maintenance)","categories":[],"tags":[{"name":"开发流程","slug":"开发流程","permalink":"http://jinzhan.github.io/tags/开发流程/"}]},{"title":"如何进行日志分析","slug":"2016/how-to-analyze-log","date":"2016-04-18T11:26:25.000Z","updated":"2018-11-25T16:08:34.374Z","comments":true,"path":"04/18/2016/how-to-analyze-log/","link":"","permalink":"http://jinzhan.github.io/04/18/2016/how-to-analyze-log/","excerpt":"","text":"定位模块所在集群###附加 Iknow数据库集群","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jinzhan.github.io/tags/mysql/"}]},{"title":"前端模板分析","slug":"2016/template-regist-function","date":"2016-04-16T07:16:59.000Z","updated":"2018-11-25T16:08:34.376Z","comments":true,"path":"04/16/2016/template-regist-function/","link":"","permalink":"http://jinzhan.github.io/04/16/2016/template-regist-function/","excerpt":"","text":"前端模板","categories":[],"tags":[{"name":"template","slug":"template","permalink":"http://jinzhan.github.io/tags/template/"}]},{"title":"学习使用nginx","slug":"2016/getting-start-to-use-nginx","date":"2016-04-16T01:09:09.000Z","updated":"2018-11-25T16:08:34.373Z","comments":true,"path":"04/16/2016/getting-start-to-use-nginx/","link":"","permalink":"http://jinzhan.github.io/04/16/2016/getting-start-to-use-nginx/","excerpt":"","text":"##nginx启动、重启、关闭 ###启动 12cd usr/local/nginx/sbin./nginx ###重启 更改配置重启nginx 1234567891011kill -HUP 主进程号或进程号文件路径或cd /usr/local/nginx/sbin./nginx -s reload# 判断配置文件是否正确 nginx -t -c /usr/local/nginx/conf/nginx.conf或cd /usr/local/nginx/sbin./nginx -t ###关闭 查询nginx主进程号 ps -ef | grep nginx 从容停止 kill -QUIT 主进程号 快速停止 kill -TERM 主进程号 强制停止 kill -9 nginx 若nginx.conf配置了pid文件路径，如果没有，则在logs目录下 1kill -信号类型 '/usr/local/nginx/logs/nginx.pid' ###升级 先用新程序替换旧程序文件 kill -USR2 旧版程序的主进程号或者进程文件名 此时旧的nginx主进程会把自己的进程文件改名为.oldbin，然后执行新版nginx，此时新旧版本同时运行 kill -WINCH 旧版本主进程号 不重载配置启动新/旧工作进程 kill -HUP 旧/新版本主进程号 从容关闭旧/新进程 kill -QUIT 旧/新进程号 快速关闭旧/新进程 kill -TERM 旧/新进程号","categories":[],"tags":[{"name":"tip","slug":"tip","permalink":"http://jinzhan.github.io/tags/tip/"}]},{"title":"如何做到高效面试","slug":"2016/how-to-make-a-interview","date":"2016-04-15T08:19:29.000Z","updated":"2018-11-25T16:08:34.374Z","comments":true,"path":"04/15/2016/how-to-make-a-interview/","link":"","permalink":"http://jinzhan.github.io/04/15/2016/how-to-make-a-interview/","excerpt":"","text":"面试准备1.明确岗位要求，研究简历 根据岗位要求，明确岗位素质（软性，硬性素质） 提前研究简历，寻找亮点项目和技能 2.设计提问框架，梯度式问题组合 针对硬性、软性素质，设计提问。比如：考察学习能力，从行业领先技术的了解程度，自身知识理解等纬度考察； 问题排列组合，梯度设计，软性-硬性-软性素质 3.项目提问：STAR法穿插专业性提问 使用STAR模板，将step1中选中的亮点项目进行问题设计 用STAR提问项目，是为了验证step2中设计的问题考察点 4.综合素质-软题库，前沿性知识提问 提问建立以外的开发性问题 对未来发展方向自己的认识 了解合作能力等软性素质 面试环节第1轮 技术基础 编程语言（语言掌握情况，实际代码编写能力） 抽象能力（对于问题本身如何抽象，能否映射到具体的方法、算法上去） 数据结构（对数据结构的理解、应用，能否根据问题进行数据结构变换以解决复杂问题） 算法掌握（对于算法题本身，重点考察对于题目的解决思路，以及候选人对问题的理解和判断） 系统知识（系统的整体认识及核心问题理解：如linux内存分配方法，CPU调度，tcp/ip实现等） 第2轮 综合素质技术广度 &amp; 深度 考察候选人在广度或深度上的认识和表现。 判定在项目上实际做到的广度或深度，客观反应其技术能力。 关注工作经验与职位的match程度，判断在这个职位上可能做到的程度。 主动性 工作积极主动，善于获得资源来解决问题。 示例： 举一个在工作中主动提建设性建议的例子； 在资源有限的情况下,你是如何解决问题的? 项目经验 项目本身的复杂程度，和岗位的相关性，面试者在项目里面的职责，是否负责架构设计，核心程序编写等。 示例： 是否参加过大型项目，在项目中承担的职责； 这些项目与我公司项目的相关性 逻辑思维 包括个人对于问题的分析、归纳、推理和判断 思路清晰，对事件描述符合逻辑、严密、有条理；工作经验是否系统性全面 示例： 请讲一下您以往的工作/学习经历; 描述一下某个项目中您的职责。 理解能力 &amp; 学习能力 积极地获取与工作有关的信息和知识，并对其进行加工和理解，以不断更新知识结构、提高能力 示例: 你最近一次更新你的知识结构是什么时候,什么原因促使你做这样的更新,你是如何获得相应的知识的? 通过提问一些不熟悉的问题,逐步引导,观察反应 沟通协作 &amp; 团队合作 能够有效倾听，清晰地表达自己的观点；愿意帮助或协助他人做事、喜欢集体活动，与周围人和谐相处 示例： 我想知道你曾经遇到过的最有挑战的沟通方面的问题。你为什么认为那次经历对你最富有挑战性，你是如何应对的？ 请举一个你在团队中工作时所遇到的困难. 你是怎样解决这个困难的？举例说明你和团队的同事有不同意见的时候是如何处理的？ 提问方法（深层探究，漏斗技巧） 你当时想达到什么目的？ 你做的第一件事是什么，为什么？ 你究竟如何做的？ 还有谁参与？ 你的角色/作用是什么？ 你当时怎么想的（按思路顺序）？ 你的感觉是什么？ 在这期间还有什么重要的事情发生吗？ 最后结果如何？ 你是怎么知道这个结果的？ 还有什么要补充的吗？ 告诉我…… 举出实例…… 为何…… 如何…… 你是否…… 硬性素质提问技巧 - STAR法则Situation情景 描述一个具体情景中，自己所处位置及其他背景信息 设计问题：项目需求产生的背景，在项目中扮演的角色 Task任务 基于前面交代的情景，如何明确自己的目标和任务 设计问题：目标是什么？如何设定目标的？如何拆解目标？ Action 基于前面的目标，有什么行动，具体方案，为什么，如何做 设计问题：基于目标的拆解，是如何行动的，过程遇到什么问题，挑战 Result 行动带来的结果，成效与挑战；目标完成结果；对结果的反思，个人总结； 设计问题：基于行动，收到了什么成就，是否完成目标；有何经验供以后借鉴 如何从面试表现预测工作表现 操作维度 （能按操作说明操作，不代表他的知识或能力） 知识纬度 （“知其然”只是操作技术层面，“志气所以然”才是真正的知识层面） 经验纬度 （看你对做过事情的反思和总结，对他人的学习和观察交流，是知识的运用和驾驭） 能力纬度 （一个人的能力，主要从做事情的态度、行为方法看，因为前三者都可以通过时间积累）","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"http://jinzhan.github.io/tags/interview/"}]},{"title":"Web性能优化概述","slug":"2016/high-performance-browser-networking","date":"2016-04-05T02:42:59.000Z","updated":"2018-11-25T16:08:34.373Z","comments":true,"path":"04/05/2016/high-performance-browser-networking/","link":"","permalink":"http://jinzhan.github.io/04/05/2016/high-performance-browser-networking/","excerpt":"","text":"“合格的开发者知道怎么做，而优秀的开发者知道为什么那么做。” 钻研基础知识与紧跟最新动向本身是一对矛盾，很难平衡。可是没有基础，那只能是“墙上芦苇，头重脚轻根底浅”。光知道表面上的那点东西可不行。需要解决难题的时，发生异常状况时，理解基础知识的人会脱颖而出。","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://jinzhan.github.io/tags/性能优化/"}]},{"title":"SQL中Group By的常见场景","slug":"2016/sql-group-by","date":"2016-03-17T07:16:59.000Z","updated":"2018-11-25T16:08:34.375Z","comments":true,"path":"03/17/2016/sql-group-by/","link":"","permalink":"http://jinzhan.github.io/03/17/2016/sql-group-by/","excerpt":"","text":"概述“Group By”从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理。 示例原始表 类别 数量 摘要 a 5 a1 a 3 a2 b 15 b1 b 30 b2 a 15 a3 c 20 c2 c 25 c1 a 3 a2 group by实例简单group by123select 类别, sum(数量) as 数量之和from Agroup by 类别 类别 数量之和 a 50 b 70 c 30 Group By 和 Order By 1234select 类别, sum(数量) AS 数量之和from Agroup by 类别order by sum(数量) desc 类别 数量之和 a 50 b 70 c 30 Group By中Select指定的字段限制 在select指定的字段要么就要包含在Group By语句的后面，作为分组的依据；要么就要被包含在聚合函数中。 12345-- 下面的sql语句是错误的：select 类别, sum(数量) as 数量之和, 摘要from Agroup by 类别order by 类别 desc 聚合函数 函数 作用 sum(列名) 求和 max(列名) 最大值 min(列名) 最小值 avg(列名) 平均值 count(列名) 除null外的记录数 count(*) 统计记录数包含null count(distinct 列名) 除null和重复数据后记录数 12345678--- 求各组平均值select 类别, avg(数量) AS 平均值 from A group by 类别;--- 求各组记录数目select 类别, count(*) AS 记录数 from A group by 类别;--- 求记录总数select 类别, sum(数量) AS 数量之和 from A group by 类别; Having与Where的区别 where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，where条件中不能包含聚组函数，使用where条件过滤出特定的行。 having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件过滤出特定的组，也可以使用多个分组标准进行分组。 12345678910--- where条件不能包含聚合函数select 类别, sum(数量) as 数量之和 from Agroup by 类别having sum(数量) &gt; 18--- Having和Where的联合使用方法select 类别, SUM(数量)from Awhere 数量 &gt; 8group by 类别having SUM(数量) &gt; 10 Case 123456789101112131415161718192021222324252627282930313233343536--- |:--位置--:|:--分类id--:|:--cms配置id--:|:--点击量--:|:--点击uv--:|:--展现量--:|:--展现uv--:|select va.area, va.classId, va.cmsId, va.pv, va.uv, vb.pv, vb.uvfrom ( select hk_urlfields['area'] as area, hk_urlfields['classId'] as classId, hk_urlfields['cmsId'] as cmsId, count(1) as pv, count(distinct baiduid) as uv from reduced_iknow_wap_lighttpd where dt = '&#123;@date&#125;' and hk_urlfields['pid'] = '102' and hk_urlfields['page'] = 'question' and hk_urlfields['action'] = 'click' and hk_urlfields['area'] in ('top_banner', 'text_banner','middle_promote','bom_fix_banner') group by hk_urlfields['area'], hk_urlfields['classId'], hk_urlfields['cmsId']) va join ( select ts.area as area, ts.classId as classId, ts.cmsId as cmsId, count(1) as pv, count(distinct ts.bid) as uv from ( select transform(hk.cmsKey, hk.classId, hk.bid) using '$&#123;hiveconf:HDFS_PHP&#125; decodeCmsKey.php' as (area string, cmsId string, classId string, bid string) from ( select hk_urlfields['cmsKey'] as cmsKey, hk_urlfields['classId'] as classId, baiduid as bid from reduced_iknow_wap_lighttpd where dt = '&#123;@date&#125;' and hk_urlfields['pid'] = '102' and hk_urlfields['page'] = 'question' and hk_urlfields['action'] = 'pv' and hk_urlfields['cmsKey'] is not NULL ---- group by hk_urlfields['cmsKey'], hk_urlfields['classId'], baiduid ) hk ) ts group by ts.area, ts.classId, ts.cmsId) vb on(va.area = vb.area and va.classId = vb.classId and va.cmsId = vb.cmsId) 参考资料 http://www.cnblogs.com/rainman/archive/2013/05/01/3053703.html","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jinzhan.github.io/tags/mysql/"}]},{"title":"ThinkPHP数据模型相关操作","slug":"2016/think-php-data-handle","date":"2016-02-18T03:18:30.000Z","updated":"2018-11-25T16:08:34.376Z","comments":true,"path":"02/18/2016/think-php-data-handle/","link":"","permalink":"http://jinzhan.github.io/02/18/2016/think-php-data-handle/","excerpt":"","text":"目录结构 初始目录结构 123456www WEB部署目录（或者子目录）├─index.php 入口文件├─README.md README文件├─Application 应用目录，默认为空。第一次访问入口文件会自动生成，参考后面的入口文件部分。├─Public 资源文件目录└─ThinkPHP 框架目录 框架目录ThinkPHP 12345678910111213141516├─ThinkPHP 框架系统目录（可以部署在非web目录下面）│ ├─Common 核心公共函数目录│ ├─Conf 核心配置目录 │ ├─Lang 核心语言包目录│ ├─Library 框架类库目录│ │ ├─Think 核心Think类库包目录│ │ ├─Behavior 行为类库目录│ │ ├─Org Org类库包目录│ │ ├─Vendor 第三方类库目录│ │ ├─ ... 更多类库目录│ ├─Mode 框架应用模式目录│ ├─Tpl 系统模板目录│ ├─LICENSE.txt 框架授权协议文件│ ├─logo.png 框架LOGO文件│ ├─README.txt 框架README文件│ └─ThinkPHP.php 框架入口文件 上述应用的目录结构只是默认设置，事实上，在实际部署应用的时候，建议除了应用入口文件和Public资源目录外，其他文件都放到非WEB目录下面，具有更好的安全性。 添加记录123456$user = M('User');$data['username'] = 'ThinkPHP';$data['email'] = 'ThinkPHP@gmail.com';$user-&gt;create($data);$record = $user-&gt;add();dump($record); add()返回的是插入数据的id,对于不存在的表字段，add()方法会自动过滤。 读取记录在ThinkPHP中读取数据的方式很多，通常分为读取数据、读取数据集和读取字段值 123$user = M('User');$record = $user-&gt;where('username=\"ThinkPHP\"')-&gt;find();dump($record); 读取字段值123$user = M('User');$record = $user-&gt;where('id=3')-&gt;getField('username');dump($record); 默认情况下，当只有一个字段的时候，返回满足条件的数据表中的该字段的第一行的值.如果getField()传入多个字段，返回值将是一个关联数组：123$user = M('User');$record = $user-&gt;getField('username,email');dump($record); 这个数组总是以传入的第一个第一个字段为键值的。如果修改为：123$user = M('User');$record = $user-&gt;getField('email,username');dump($record); 将上面的两次代码分别放到testDemo()，你就会看到不一样的结果集。 用save()方法更新数据12345$user = M('User');$data['username'] = 'ThinkPHPSave';$data['email'] = 'ThinkPHPSave@outlook.com';$record = $user-&gt;where('id=3')-&gt;save($data);dump($record); 这里的$record返回1，表示成功更改。 当然，你也可以这样： 12345$user = M('User');$user-&gt;username = 'ThinkPHP';$user-&gt;email = 'ThinkPHP@outlook.com';$record = $user-&gt;where('id=3')-&gt;save();dump($record); 日常开发的时候经常会遇到一些只更新某些字段的情况，可以通过下面的方式来实现： 1234$user = M(\"User\"); $record = $user-&gt;where('id=4')-&gt;setField('username','ThinkPHPChangeName');dump($record); 同时更新多个字段，可以将数据以数组的形式传给setField()方法： 1234$user = M('User');$data = array('username'=&gt;'ThinkPHPChangeArray','email'=&gt;'ThinkPHP@array.com');$record = $user-&gt; where('id=6')-&gt;setField($data);dump($record); ThinkPHP删除数据使用delete()方法123$user = M('User');$record = $user-&gt;where('id=3')-&gt;delete();dump($record); 或者你可以直接使用：12$record = $user-&gt;delete('1,2,5');dump($record); 这样就达到了删除主键1,2,5这三条记录了。 ActiveRecordsThinkPHP实现了ActiveRecords模式的ORM模型，采用了非标准的ORM模型：表映射到类，记录映射到对象。以下实例将使用ActiveRecords重现对数据表的CURD，看看ActiveRecords给我们带来了什么好处。123456$user = M(\"User\");$user-&gt;username = 'ThinkPHPWithActive';$user-&gt;email = 'ThinkPHPActive@gmail.com';$record = $user-&gt;add();dump($record); 读取记录AR最大的特点可能就是它的查询模式了，模式简单易用，因为更多情况下面查询条件都是以主键或者某个关键的字段。这种类型的查询，ThinkPHP有着很好的支持。 比如说获取主键为2的用户信息： 123$user = M(\"User\");$record = $user-&gt;find(2);dump($record); 直接不用where()查询了，简单友好吧。再比如： 1234$user = M(\"User\");$record = $user-&gt;getByUsername(\"jelly\");dump($record); 如果是查询多条记录，使用以下方式：123$user = M(\"User\");$record = $user-&gt;select('1,3,8');dump($record); 更新记录12345$user = M(\"User\");$user-&gt;find(21);$user-&gt;username = 'TOPThinkChangeWithAR';$record = $user-&gt;save();dump($record); 删除记录 删除单条记录 123$user = M(\"User\");$record = $user-&gt;delete(8);dump($record); 删除多条记录123$user = M(\"User\");$record = $user-&gt;delete('15,16');dump($record); 自动完成自动完成是ThinkPHP提供用来完成数据自动处理和过滤的方法，当使用create()方法创建数据对象的时候会触发自动完成数机制。 因此，在ThinkPHP鼓励使用create()方法来创建数据对象，因为这是一种更加安全的方式，直接通过add()或者save()方法实现数据写入无法出发自动完成机制。 自动完成通常用来完成默认字段写入(比如添加时间戳)，安全字段过滤(比如加密密码)以及业务逻辑的自动处理等。可以通过模型类里面通过$_auto属性定义处理规则。下面演示如何自动完成添加时间戳： 在UserModel中，声明自动完成的定义数组$_auto ： 1234protected $_auto = array ( array('created_at','date(\"Y-m-d H:i:s\", time())',3,'function'), array('updated_at','date(\"Y-m-d H:i:s\", time())',3,'function'), ); 还有一种是理由auto()方法动态设置自动完成的机制，可以到官方文档去看看 设置完成之后，我们在testDemo()方法中创建一条用户数据： 123456$user = D('User');$data['username'] = \"ThinkPHP\";$data['email'] = \"ThinkPHP@gmail.com\";$user-&gt;create($data);$record = $user-&gt;add();dump($record); 测试，如果返回记录的id值，说明用户记录创建成功。要验证数据是否自动完成，你可以直接使用：123$user = D('User');$record = $user-&gt;find(id);dump($record); 自动验证自动验证是ThinkPHP模型层提供的一种数据验证方法，可以在使用create()创建数据对象的时候自动进行数据验证。 数据验证可以进行数据类型、业务规则、安全判断等方面的验证操作。 通常用于表单验证 数据验证有两种方式： 静态方式：在模型类里面通过$_validate属性定义验证规则。 动态方式：使用模型类的validate()方法动态创建自动验证规则。 无论是什么方式，验证规则的定义是统一的规则，定义格式为： 12345array( array(验证字段1,验证规则,错误提示,[验证条件,附加规则,验证时间]), array(验证字段2,验证规则,错误提示,[验证条件,附加规则,验证时间]), ......); 下面以$_validate静态方式举例如何使用自动验证： 在UserController中创建register()方法，对，几乎每一个Web应用都需要实现用户注册这一步。1234public function register() &#123; $this-&gt;display(); &#125; 对，就是这么简单，这个方法只是将相应的视图文件渲染出来。所以接下来我们创建对应的视图文件，也就是：./Application/Home/View/User/register.html 123456789101112131415&lt;extend name=\"Index/base\" /&gt;&lt;block name=\"main\" &gt;&lt;form method=\"post\" action=\"__URL__/registerValidate\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName\"&gt;Name&lt;/label&gt; &lt;input type=\"text\" name=\"username\" class=\"form-control\" id=\"exampleInputName\" placeholder=\"Name\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail\"&gt;Email&lt;/label&gt; &lt;input type=\"email\" name=\"email\" class=\"form-control\" id=\"exampleInputEmail\" placeholder=\"Email\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/block&gt; 上面就是一些HTML代码和一点模板的知识，对于模板，我们后续会讲到，但不管怎样，现在我们访问http://localhost:8999/Home/User/register，就可以看到我们的注册表单页面了。 注意到form表单中，action=”URL/registerValidate”，这表示提交到当前的控制器的registerValidate()方法处理，所以我们在UserController中增加registerValidate()方法： 1234567891011public function registerValidate() &#123; $data['username'] = $_POST['username']; $data['email'] = $_POST['email']; $user = D(\"User\"); if ( !$user-&gt;create($data) ) &#123; exit($user-&gt;getError()); &#125; //todo: validation passes, add data to database and redirect somewhere echo 'validation passes'; &#125; 这里的if ( !$user-&gt;create($data) )会触发自动验证并判断验证是否通过验证。你可以尝试在表单里填写不同的数据来进行测试，也可以修改一下验证规则，更多规则可以到官网查看： http://document.thinkphp.cn/manual_3_2.html#auto_validate 关联模型通常我们所说的关联关系包括下面三种： 123一对一关联 ：ONE_TO_ONE，包括HAS_ONE 和 BELONGS_TO一对多关联 ：ONE_TO_MANY，包括HAS_MANY 和 BELONGS_TO多对多关联 ：MANY_TO_MANY 关联定义ThinkPHP可以很轻松的完成数据表的关联CURD操作，目前支持的关联关系包括下面四种： HAS_ONE、BELONGS_TO、HAS_MANY和MANY_TO_MANY。 一个模型根据业务模型的复杂程度可以同时定义多个关联，不受限制，所有的关联定义都统一在模型类的 $_link 成员变量里面定义，并且可以支持动态定义。要支持关联操作，模型类必须继承Think\\Model\\RelationModel类，关联定义的格式类似于： 12345678910namespace Home\\Model;use Think\\Model\\RelationModel;class UserModel extends RelationModel&#123; protected $_link = array( '关联' =&gt; array( '关联属性1' =&gt; '定义', '关联属性N' =&gt; '定义', ), );&#125; 关于关联属性的定义和值，你可以到官方文档仔细查看，我们下面也会给出一些最常用的。 在我们的讲解例子中，会采用HAS_MANY和BELONGS_TO来演示，对于其他的几个关系模型，可以参考官方文档举一反三。 首先我们知道数据库里面有两张表，用户表和文章表，并且我们也为其创建了不同的模型(UserModel ArticelModel)。 现在我们仔细来想想他们之间的对应关系：一个用户可以拥有多篇文章，而每一篇文章都属于某个特定的用户。所以我们可以分别为这两种关系添加关联模型： 在UserModel中： 123protected $_link = array( 'Article' =&gt; self::HAS_MANY ); 在ArticleModel中： 123protected $_link = array( 'User' =&gt; self::BELONGS_TO ); 以上者两种都是最简洁的模型关联声明。因为在最开始设计数据库的时候，我们遵守了ThinkPHP的官方的规范： 外键的默认规则是当前数据对象名称_id，例如：UserModel对应的可能是表think_user，那么think_user表的外键默认为user_id，如果你的外键不是user_id，而是其他自定义的字段如：user_identify，那么就必须在定义关联的时候定义 foreign_key 。如下： 在UserModel中： 12345protected $_link = array( 'mapping_type' =&gt; self::HAS_MANY, 'class_name' =&gt; 'Article', 'foreign_key' =&gt; 'user_identify', ); 更多自定义的关联模型参数可以到官网查看。 有了以上的定义之后，我们就可以在检索用户数据的同时将属于他的文章也一起检索出来，使用relation()。 同样是在testDemo()这个方法中： 123$user = D('User');$record = $user-&gt;relation(true)-&gt;find(4);dump($record);","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jinzhan.github.io/tags/PHP/"}]},{"title":"PHP的一些优秀开源库","slug":"2016/php-lib-collection","date":"2016-02-18T03:18:30.000Z","updated":"2018-11-25T16:08:34.375Z","comments":true,"path":"02/18/2016/php-lib-collection/","link":"","permalink":"http://jinzhan.github.io/02/18/2016/php-lib-collection/","excerpt":"","text":"1.Dispatch – 微框架Dispatch是一个PHP小框架。它并没有给你完整的MVC设置，但你可以定义URL规则和方法，以便更好组织应用程序。这对API、简单的站点或原型来说是完美的。 1234567891011121314151617181920//包含库include 'dispatch.php'; // 定义你的路由get('/greet', function () &#123; //渲染视图 render('greet-form');&#125;); //post处理post('/greet', function () &#123; $name = from($_POST, 'name'); // render a view while passing some locals render('greet-show', array('name' =&gt; $name));&#125;); // serve your sitedispatch(); 你可以匹配特定类型的HTTP请求和路径，渲染视图或做更多事情。如果你合并Dispatch和其他框架，那你就可以拥有一个相当强大并且轻量级的程序！ 2. Klein – PHP快如闪电的路由Klein是另一款针对PHP5.3+版本的轻量级路由库。虽然它有一些比Dispatch冗长的语法，但它相当快。这有一个例子： 123respond('/[:name]', function ($request) &#123; echo 'Hello ' . $request-&gt;name;&#125;); 你也可以定制来指定HTTP方法和使用正则表达式作为路径。 123456789101112131415respond('GET', '/posts', $callback);respond('POST', '/posts/create', $callback);respond('PUT', '/posts/[i:id]', $callback);respond('DELETE', '/posts/[i:id]', $callback); //匹配多种请求方法:respond(array('POST','GET'), $route, $callback); //你或许也想在相同的地方处理请求respond('/posts/[create|edit:action] /[i:id] ', function ($request, $response) &#123; switch ($request-&gt;action) &#123; // do something &#125;&#125;); 对于小型项目来说这是很棒的，但当你把一个像这样的库用于大型应用时，你不得不遵守规矩，因为你的代码可能很快就变得不可维护。所以你最好搭配一个像Laravel或者CodeIgniter这样完全成熟的框架。 3. Ham – 带缓存的路由库Ham也是一款轻量级的路由框架，但是它利用缓存甚至获得了更快的速度。它通过把任何I/O相关的东西缓存进XCache/APC。下面是一个例子： 123456789101112131415161718require '../ham/ham.php'; $app = new Ham('example');$app-&gt;config_from_file('settings.php'); $app-&gt;route('/pork', function($app) &#123; return \"Delicious pork.\";&#125;); $hello = function($app, $name='world') &#123; return $app-&gt;render('hello.html', array( 'name' =&gt; $name ));&#125;;$app-&gt;route('/hello/&lt;string&gt;', $hello);$app-&gt;route('/', $hello); $app-&gt;run(); 这个库要求你至少安装了XCache和APC其中的一个，这可能意味着，在大多数主机提供商提供的主机上它可能用不了。但是如果你拥有一个安装它们其一的主机，或者你可以操控你的web服务器，你应该尝试这款最快的框架。 4. Assetic – 资源管理Assetic是一个PHP的资源管理框架，用于合并和减小了CSS/JS资源。下面是例子。 1234567891011use Assetic\\Asset\\AssetCollection;use Assetic\\Asset\\FileAsset;use Assetic\\Asset\\GlobAsset; $js = new AssetCollection(array( new GlobAsset('/path/to/js/*'), new FileAsset('/path/to/another.js'),)); //当资源被输出时，代码会被合并echo $js-&gt;dump(); 以这种方式合并资源是一个好主意，因为它可以加速站点。不仅仅总下载量减小了，也消除了大量不必要的HTTP请求(这是最影响页面加载时间的两件事) 5. ImageWorkshop – 带层的图片处理ImageWorkshop是一个让你操控带层图片的开源库。借助它你可以重定义尺寸、裁剪、制作缩略图、打水印或做更多事情。下面是一个例子： 12345678910111213// 从norway.jpg图片初始化norway层$norwayLayer = ImageWorkshop::initFromPath('/path/to/images/norway.jpg'); // 从watermark.png图片初始化watermark层(水印层)$watermarkLayer = ImageWorkshop::initFromPath('/path/to/images/watermark.png'); $image = $norwayLayer-&gt;getResult(); // 这是生成的图片! header('Content-type: image/jpeg');imagejpeg($image, null, 95); // We choose to show a JPG with a quality of 95%exit; ImageWorkshop被开发用于使一些PHP中最通用的处理图片的案例简化，如果你需要一些更强大的东西，你应该看下Imagine library！ 6. Snappy – 快照/PDF库Snappy是一个PHP5库，可以生成快照、URL、HTML、PDF。它依赖于wkhtmltopdf binary（在Linux，Windows和OSX上都可用）。你可以像这样使用它们： 12345678910111213require_once '/path/to/snappy/src/autoload.php'; use Knp\\Snappy\\Pdf; //通过wkhtmltopdf binary路径初始化库$snappy = new Pdf('/usr/local/bin/wkhtmltopdf'); //通过把Content-type头设置为pdf来在浏览器中展示pdf header('Content-Type: application/pdf');header('Content-Disposition: attachment; filename=\"file.pdf\"'); echo $snappy-&gt;getOutput('http://www.github.com'); 要记得，你的主机提供商可能不允许调用外部二进制程序。 7. Idiorm – 轻量级ORM库Idiorm是个人之前在本网站教程中用过最喜爱的一款。它是一款轻量级的ORM库，一个建立在PDO之上的PHP5查询构造器。借助它，你可以忘记如何书写乏味的SQL： 123456789101112131415161718$user = ORM::for_table('user') -&gt;where_equal('username', 'j4mie') -&gt;find_one(); $user-&gt;first_name = 'Jamie';$user-&gt;save(); $tweets = ORM::for_table('tweet') -&gt;select('tweet.*') -&gt;join('user', array( 'user.id', '=', 'tweet.user_id' )) -&gt;where_equal('user.username', 'j4mie') -&gt;find_many(); foreach ($tweets as $tweet) &#123; echo $tweet-&gt;text;&#125; diorm有一个姊妹库叫Paris，Paris是一个基于Idiorm的Active Record实现。 8. Underscore – PHP的工具腰带Underscore是原始Underscore.js的一个接口 – Javascript应用的工具腰带。PHP版本没有让人失望，而且支持了几乎所有原生功能。下面是一些例子： __::each(array(1, 2, 3), function($num) { echo $num . ‘,’; });// 1,2,3, $multiplier = 2;__::each(array(1, 2, 3), function($num, $index) use ($multiplier) { echo $index . ‘=’ . ($num * $multiplier) . ‘,’;});// prints: 0=2,1=4,2=6, __::reduce(array(1, 2, 3), function($memo, $num) { return $memo + $num; }, 0);// 6 __::find(array(1, 2, 3, 4), function($num) { return $num % 2 === 0; });// 2 __::filter(array(1, 2, 3, 4), function($num) { return $num % 2 === 0; });// array(2, 4)这个库也支持链式语法，这使得它更为强大。 9. Requests – 简单HTTP请求Requests是一个简化HTTP请求的库。如果你和我一样，几乎从来都记不住传递给Curl的各种各样的参数，那么它就是为你准备的：123456789101112$headers = array('Accept' =&gt; 'application/json');$options = array('auth' =&gt; array('user', 'pass'));$request = Requests::get('https://api.github.com/gists', $headers, $options); var_dump($request-&gt;status_code);// int(200) var_dump($request-&gt;headers['content-type']);// string(31) \"application/json; charset=utf-8\" var_dump($request-&gt;body);// string(26891) \"[…]\" 借助这个库，你可以发送HEAD、GET、POST、PUT、DELTE和PATCH HTTP请求，你可以通过数组添加文件和参数，并且可以访问所有相应数据。 10. Buzz – 简单的HTTP请求库Buzz是另一个完成HTTP请求的库。下面是一个例子：12345678$request = new Buzz\\Message\\Request('HEAD', '/', 'http://google.com');$response = new Buzz\\Message\\Response(); $client = new Buzz\\Client\\FileGetContents();$client-&gt;send($request, $response); echo $request;echo $response; 因为它缺乏文档，所以你不得不阅读源码来获知它支持的所有参数。 11. Goutte – Web抓取库Goutte是一个抓取网站和提取数据的库。它提供了一个优雅的API，这使得从远程页面上选择特定元素变得简单。 123456789101112131415require_once '/path/to/goutte.phar'; use Goutte\\Client; $client = new Client();$crawler = $client-&gt;request('GET', 'http://www.symfony-project.org/'); //点击链接$link = $crawler-&gt;selectLink('Plugins')-&gt;link();$crawler = $client-&gt;click($link); //使用一个类CSS语法提取数据$t = $crawler-&gt;filter('#data')-&gt;text(); echo \"Here is the text: $t\"; 12. Carbon – DateTime 库Carbon 是 DateTime API 的一个简单扩展。1234567891011121314151617181920212223242526printf(\"Right now is %s\", Carbon::now()-&gt;toDateTimeString());printf(\"Right now in Vancouver is %s\", Carbon::now('America/Vancouver')); $tomorrow = Carbon::now()-&gt;addDay();$lastWeek = Carbon::now()-&gt;subWeek();$nextSummerOlympics = Carbon::createFromDate(2012)-&gt;addYears(4); $officialDate = Carbon::now()-&gt;toRFC2822String(); $howOldAmI = Carbon::createFromDate(1975, 5, 21)-&gt;age; $noonTodayLondonTime = Carbon::createFromTime(12, 0, 0, 'Europe/London'); $endOfWorld = Carbon::createFromDate(2012, 12, 21, 'GMT'); //总是以UTC对比if (Carbon::now()-&gt;gte($endOfWorld)) &#123; die();&#125; if (Carbon::now()-&gt;isWeekend()) &#123; echo 'Party!';&#125; echo Carbon::now()-&gt;subMinutes(2)-&gt;diffForHumans(); // '2分钟之前' 13. Ubench – 微型基准库Ubench 是一个用于评测PHP代码的微型库，可监控（代码）执行时间和内存使用率。下面是范例：12345678910111213141516171819202122232425262728use Ubench\\Ubench; $bench = new Ubench; $bench-&gt;start(); //执行一些代码 $bench-&gt;end(); //获取执行消耗时间和内存echo $bench-&gt;getTime(); // 156ms or 1.123secho $bench-&gt;getTime(true); // elapsed microtime in floatecho $bench-&gt;getTime(false, '%d%s'); // 156ms or 1s echo $bench-&gt;getMemoryPeak(); // 152B or 90.00Kb or 15.23Mbecho $bench-&gt;getMemoryPeak(true); // memory peak in bytes 内存峰值echo $bench-&gt;getMemoryPeak(false, '%.3f%s'); // 152B or 90.152Kb or 15.234Mb //在结束标识处返回内存使用情况echo $bench-&gt;getMemoryUsage(); // 152B or 90.00Kb or 15.23Mb (仅)在开发时运行这些校验是一个好主意。 14. Validation – 输入验证引擎Validation 声称是PHP库里最强大的验证引擎。但是，它能名副其实吗？看下面：1234567891011121314151617181920212223use Respect\\Validation\\Validator as v; //简单验证$number = 123;v::numeric()-&gt;validate($number); //true //链式验证$usernameValidator = v::alnum()-&gt;noWhitespace()-&gt;length(1,15);$usernameValidator-&gt;validate('alganet'); //true //验证对象属性$user = new stdClass;$user-&gt;name = 'Alexandre';$user-&gt;birthdate = '1987-07-01'; //在一个简单链中验证他的属性$userValidator = v::attribute('name', v::string()-&gt;length(1,32)) -&gt;attribute('birthdate', v::date()-&gt;minimumAge(18)); $userValidator-&gt;validate($user); //true 你可以通过这个库验证你的表单或其他用户提交的数据。除此之外，它内置了很多校验，抛出异常和定制错误信息。 15. Filterus – 过滤库Filterus是另一个过滤库，但它不仅仅可以验证，也可以过滤匹配预设模式的输出。下面是一个例子：1234567$f = Filter::factory('string,max:5');$str = 'This is a test string'; $f-&gt;validate($str); // false$f-&gt;filter($str); // 'This ' Filterus有很多内建模式，支持链式用法，甚至可以用独立的验证规则去验证数组元素。 16. Faker – 假数据生成器Faker 是一个为你生成假数据的PHP库。当你需要填充一个测试数据库，或为你的web应用生成测试数据时，它能派上用场。它也非常容易使用：1234567891011121314151617181920//引用Faker 自动加载器require_once '/path/to/Faker/src/autoload.php'; //使用工厂创建来创建一个Faker\\Generator实例$faker = Faker\\Factory::create(); //通过访问属性生成假数据echo $faker-&gt;name; // 'Lucy Cechtelar'; echo $faker-&gt;address; // \"426 Jordy Lodge // Cartwrightshire, SC 88120-6700\" echo $faker-&gt;text; // Sint velit eveniet. Rerum atque repellat voluptatem quia ...只要你继续访问对象属性，它将继续返回随机生成的数据。 17. Mustache.php – 优雅模板库Mustache.php是一款流行的模板语言，实际已经在各种编程语言中得到实现。使用它，你可以在客户端或服务段重用模板。 正如你猜得那样，Mustache.php 是使用PHP实现的。 $m = new Mustache_Engine;echo $m-&gt;render(‘Hello ‘, array(‘planet’ =&gt; ‘World!’));// “Hello World!”建议看一下官方网站Mustache docs 查看更多高级的例子。 18. Gaufrette – 文件系统抽象层Gaufrette是一个PHP5库，提供了一个文件系统的抽象层。它使得以相同方式操控本地文件，FTP服务器，亚马逊 S3或更多操作变为可能。它允许你开发程序时，不用了解未来你将怎么访问你的文件。 1234567891011121314151617use Gaufrette\\Filesystem;use Gaufrette\\Adapter\\Ftp as FtpAdapter;use Gaufrette\\Adapter\\Local as LocalAdapter; //本地文件:$adapter = new LocalAdapter('/var/media'); //可选地使用一个FTP适配器// $ftp = new FtpAdapter($path, $host, $username, $password, $port); //初始化文件系统$filesystem = new Filesystem($adapter); //使用它$content = $filesystem-&gt;read('myFile');$content = 'Hello I am the new content';$filesystem-&gt;write('myFile', $content); 也有缓存和内存适配器，并且随后将会增加更多适配器。 19. Omnipay – 支付处理库Omnipay是一个PHP支付处理库。它有一个清晰一致的API，并且支持数十个网关。使用这个库，你仅仅需要学习一个API和处理各种各样的支付处理器。下面是一个例子：12345678910111213141516171819202122use Omnipay\\CreditCard;use Omnipay\\GatewayFactory; $gateway = GatewayFactory::create('Stripe');$gateway-&gt;setApiKey('abc123'); $formData = ['number' =&gt; '4111111111111111', 'expiryMonth' =&gt; 6, 'expiryYear' =&gt; 2016];$response = $gateway-&gt;purchase(['amount' =&gt; 1000, 'card' =&gt; $formData]); if ($response-&gt;isSuccessful()) &#123; //支付成功:更新数据库 print_r($response);&#125; elseif ($response-&gt;isRedirect()) &#123; //跳转到异地支付网关 $response-&gt;redirect();&#125; else &#123; //支付失败:向客户显示信息 exit($response-&gt;getMessage());&#125; 使用相同一致的API，可以很容易地支持多种支付处理器，或在需要时进行切换。 20. Upload – 处理文件上传Upload是一个简化文件上传和验证的库。上传表单时，这个库会校验文件类型和尺寸。123456789101112131415161718192021222324$storage = new \\Upload\\Storage\\FileSystem('/path/to/directory');$file = new \\Upload\\File('foo', $storage); //验证文件上传$file-&gt;addValidations(array( //确保文件类型是\"image/png\" new \\Upload\\Validation\\Mimetype('image/png'), //确保文件不超过5M(使用\"B\",\"K\",\"M\"或者\"G\") new \\Upload\\Validation\\Size('5M'))); //试图上传文件try &#123; //成功 $file-&gt;upload();&#125; catch (\\Exception $e) &#123; //失败! $errors = $file-&gt;getErrors();&#125; 它将减少不少乏味的代码。 21. HTMLPurifier – HTML XSS 防护HTMLPurifier是一个HTML过滤库，通过强大的白名单和聚集分析，保护你代码远离XSS攻击。它也确保输出标记符合标准。 (源码在github上)12345require_once '/path/to/HTMLPurifier.auto.php'; $config = HTMLPurifier_Config::createDefault();$purifier = new HTMLPurifier($config);$clean_html = $purifier-&gt;purify($dirty_html); 如果你的网站允许用户提交 HTML 代码，不修改就展示代码的话，那这时候就是用这个库的时候了。 22. ColorJizz-PHP – 颜色操控库ColorJizz是一个简单的库，借助它你可以转换不同的颜色格式，并且做简单的颜色运算123456789use MischiefCollective\\ColorJizz\\Formats\\Hex; $red_hex = new Hex(0xFF0000);$red_cmyk = $hex-&gt;toCMYK();echo $red_cmyk; // 0,1,1,0 echo Hex::fromString('red')-&gt;hue(-20)-&gt;greyscale(); // 555555 它已经支持并且可以操控所有主流颜色格式了 23. PHP Geo – 地理位置定位库phpgeo是一个简单的库，用于计算地理坐标之间高精度距离。例如： 1234567891011use Location\\Coordinate;use Location\\Distance\\Vincenty; $coordinate1 = new Coordinate(19.820664, -155.468066); // Mauna Kea Summit 茂纳凯亚峰$coordinate2 = new Coordinate(20.709722, -156.253333); // Haleakala Summit $calculator = new Vincenty();$distance = $calculator-&gt;getDistance($coordinate1, $coordinate2); // returns 128130.850 (meters; ≈128 kilometers) 它将在使用地理位置数据的app里出色工作。你可以试译 HTML5 Location API，雅虎的API（或两者都用，我们在weather web app tutorial中这样做了），来获取坐标。 24. ShellWrap – 优美的命令行包装器借助 ShellWrap 库，你可以在PHP代码里使用强大的 Linux/Unix 命令行工具。 123456789101112131415161718192021222324252627require 'ShellWrap.php';use \\MrRio\\ShellWrap as sh; //列出当前文件下的所有文件echo sh::ls(); //检出一个git分支sh::git('checkout', 'master'); //你也可以通过管道把一个命令的输出用户另一个命令//下面通过curl跟踪位置，然后通过grep过滤’html’管道来下载example.com网站echo sh::grep('html', sh::curl('http://example.com', array( 'location' =&gt; true))); //新建一个文件sh::touch('file.html'); //移除文件sh::rm('file.html'); //再次移除文件(这次失败了,然后因为文件不存在而抛出异常)try &#123; sh::rm('file.html');&#125; catch (Exception $e) &#123; echo 'Caught failing sh::rm() call';&#125; 当命令行里发生异常时，这个库抛出异常，所以你可以及时对之做出反应。它也可以通过管道让你一个命令的输出作为另一个命令的输入，来实现更强的灵活性。 参考资料","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jinzhan.github.io/tags/PHP/"}]},{"title":"关于webpack的资料整理(一)","slug":"2016/getting-started-with-webpack","date":"2016-02-17T03:45:02.000Z","updated":"2018-11-25T16:08:34.373Z","comments":true,"path":"02/17/2016/getting-started-with-webpack/","link":"","permalink":"http://jinzhan.github.io/02/17/2016/getting-started-with-webpack/","excerpt":"","text":"Webpack跟百度的FIS有一些类似之处，出自Facebook的Instagram团队。自15年以来，受到国内不少人的追捧。这里整理一下官网的一些介绍： MotivationToday’s websites are evolving into web apps: More and more JavaScript is in a page. You can do more stuff in modern browsers. Fewer full page reloads → even more code in a page. As a result there is a lot of code on the client side! A big code base needs to be organized. Module systems offer the option to split your code base into modules. Module system stylesThere are multiple standards for how to define dependencies and export values: &lt;script&gt;-tag style (without a module system) CommonJs AMD and some dialects of it ES6 modules and more… script-tag styleThis is the way you would handle a modularized code base if you didn’t use a module system. 1234&lt;script src=\"module1.js\"&gt;&lt;/script&gt;&lt;script src=\"module2.js\"&gt;&lt;/script&gt;&lt;script src=\"libraryA.js\"&gt;&lt;/script&gt;&lt;script src=\"module3.js\"&gt;&lt;/script&gt; Modules export an interface to the global object, i. e. the window object. Modules can access the interface of dependencies over the global object. Common problems Conflicts in the global object. Order of loading is important. Developers have to resolve dependencies of modules/libraries. In big projects the list can get really long and difficult to manage. CommonJs: synchronous requireThis style uses a synchronous require method to load a dependency and return an exported interface. A module can specify exports by adding properties to the exports object or setting the value of module.exports. 1234require(\"module\");require(\"../file.js\");exports.doStuff = function()&#123;&#125;;module.exports = someValue; It’s used on server-side by node.js. Pros Server-side modules can be reused There are already many modules in this style (npm) very simple and easy to use. Cons blocking calls do not apply well on networks. Network requests are asynchronous. No parallel require of multiple modules Implementations node.js - server-side browserify modules-webmake - compile to one bundle wreq - client-side AMD: asynchronous requireAsynchronous Module Definition Other module systems (for the browser) had problems with the synchronous require (CommonJs) and introduced an asynchronous version (and a way to define modules and exporting values): 1234require([\"module\", \"../file\"], function(module, file) &#123; /* ... */ &#125;);define(\"mymodule\", [\"dep1\", \"dep2\"], function(d1, d2) &#123; return someExportedValue;&#125;); Pros Fits to the asynchronous request style in networks. Parallel loading of multiple modules. Cons Coding overhead. More difficult to read and write. Seems to be some kind of workaround. Implementations require.js - client-side curl - client-side Read more about CommonJs and AMD. ES6 modulesEcmaScript6 adds some language constructs to JavaScript, which form another module system. 123import \"jquery\";export function doStuff() &#123;&#125;module \"localModule\" &#123;&#125; Pros Static analysis is easy Future-proof as ES standard Cons Native browser support will take time Very few modules in this style Unbiased solutionGive the developer the choice of the module style. Allow existing code to work. Make it easy to add custom module styles. TransferringModules should be executed on the client, so they must be transferred from the server to the browser. There are two extremes on how to transfer modules: 1 request per module all modules in one request Both are used in the wild, but both are suboptimal: 1 request per module Pro: only required modules are transferred Con: many requests means much overhead Con: slow application startup, because of request latency all modules in one request Pro: less request overhead, less latency Con: not (yet) required modules are transferred too Chunked transferringA more flexible transferring would be better. A compromise between the extremes is better in most cases. While compiling all modules: Split the set of modules into multiple smaller batches (chunks). We get multiple smaller requests. Chunks with modules that are not required initially are only requested on demand. The initial request doesn’t contain your complete code base and is smaller. The “split points” are up to the developer and optional. A big code base is possible! Note: The idea is from Google’s GWT. Read more about Code Splitting. Why only JavaScript?Why should a module system only help the developer with JavaScript? There are many other static resources that need to be handled: stylesheets images webfonts html for templating etc. And also: coffeescript → javascript elm → javascript less stylesheets → css stylesheets jade templates → javascript which generates html i18n files → something etc. This should be as easy as: 1234require(\"./style.css\");require(\"./style.less\");require(\"./template.jade\");require(\"./image.png\"); Read more about Using loaders and Loaders. Static analysisWhen compiling all the modules a static analysis tries to find dependencies. Traditionally this could only find simple stuff without expression, but i.e. require(&quot;./template/&quot; + templateName + &quot;.jade&quot;) is a common construct. Many libraries are written in different styles. Some of them are very weird… StrategyA clever parser would allow most existing code to run. If the developer does something weird it would try to find the most compatible solution. Getting Started一个最简单的Webpack配置文件webpack.config.js如下所示： 123456789101112131415module.exports = &#123; entry: [ \"./entry.js\" ], output: &#123; path: __dirname, publicPath: \"/assets/\", filename: \"bundle.js\" &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, loader: \"style!css\" &#125; ] &#125;&#125;; 其中entry参数定义了打包后的入口文件，数组中的所有文件会按顺序打包。每个文件进行依赖的递归查找，直到所有相关模块都被打包。output参数定义了输出文件的位置，其中常用的参数包括： path: 打包文件存放的绝对路径 publicPath: 网站运行时的访问路径 filename: 打包后的文件名","categories":[],"tags":[]},{"title":"使用js制作六边形边框","slug":"2016/make-a-hexagon","date":"2016-02-15T08:58:02.000Z","updated":"2018-11-25T16:08:34.374Z","comments":true,"path":"02/15/2016/make-a-hexagon/","link":"","permalink":"http://jinzhan.github.io/02/15/2016/make-a-hexagon/","excerpt":"","text":"最终效果 $(function(){ new Hexagon('.hexagon-container', { width: 300, height: 300, transitionDuration: 0.5 }); }); 背景灵感来自于这个网站LOGO图案：http://www.colorhexa.com/: 关于clip-path 该网站的logo是用svg制作而成，svg的优点是矢量图形可伸缩，这里我想使用js生成一个正六边形，增加一些动画效果，让它更加生动。生成不规则的图形一定要用svg和cavnas吗？其实通过css3提供的clip-path，就能胜任这个效果，基本思路： 这个正六边形的边，恰好是由30个等边三角形构成； 假设三角形的边长为n；则六边形的高度为：n*6，宽度为n*sin60*6； 整体用百分比，以便自适应宽高； clip-path Syntax 12345678910111213141516171819/* Keyword values */clip-path: none;clip-path: fill-box;clip-path: stroke-box;clip-path: view-box;/* Image values */clip-path: url(resources.svg#c1);clip-path: linear-gradient(blue, transparent);/* Geometry values */clip-path: inset(100px 50px);clip-path: circle(50px at 0 100px);clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);/* Global values */clip-path: inherit;clip-path: initial;clip-path: unset; 完整代码https://gist.github.com/jinzhan/31458be6c083ea3cd8f6 兼容性问题在该图案上添加了CSS动画的transition后，在chrome下面表现良好，但是在Safari及移动端失效。经追查，CSS3的transition中的clip-path并不能被safari很好的支持了。这个就只能通过js来实现动画效果了。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jinzhan.github.io/tags/javascript/"}]},{"title":"gbk编码引起的一个问题","slug":"2015/gbk-issue","date":"2016-01-30T02:48:40.000Z","updated":"2018-11-25T16:08:34.371Z","comments":true,"path":"01/30/2015/gbk-issue/","link":"","permalink":"http://jinzhan.github.io/01/30/2015/gbk-issue/","excerpt":"","text":"Context最近在一个项目中，由于转义的问题，导致页面出现报错。检查以后，发现是单引号引起的，但是转义其实已经做了如下处理： 1&lt;div ng-init='content=\"&#123;%$data.content|replace:\"'\":'\\\"'|replace:'\"':'\\\"'%&#125;\"'&gt; ... &lt;/div&gt; 奇怪的是，内容中的多个单引号，有一个单引号未被替换掉。 Analysis代码用到的是PHP的smarty模块，这里的replace等同于PHP函数的 str_replace()，即： 1str_replace('\\'', '\\\\\\'', $data.content); 这里是没有任何问题，那问题在哪儿呢？事出反常必有妖。那一定是某个特定环境的问题，如是，我想到的是项目中的GBK编码所致。 首先，gbk编码是采用双字节： GBK字符集范围GB2312字符集 作用：国家简体中文字符集，兼容ASCII。 位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。 范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码。 GBK字符集 作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。 位数：使用2个字节表示，可表示21886个字符。 范围：高字节从81到FE，低字节从40到FE。 分区 高位 低位 说明 GBK/1 A1~A9 A1~FE GB2312非汉字符号 GBK/2 B0~F7 A1~FE GB2312汉字 GBK/3 81~A0 40~FE 扩充汉字 GBK/4 AA~FE 40~A0 扩充汉字 GBK/5 A8~A9 40~A0 扩充非汉字 PS:1和2对应的GB2312字符集 ascii编码 作用：表语英语及西欧语言。 位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。 范围：ASCII从00到7F，扩展从00到FF GB2312的编码范围为2121H-777EH，与ASCII有重叠。 str_replacestr_replace的原理是按照ascii编码进行查找替换，不是多字节安全的；GBK编码下的一个经典问题，就是字符替换后的乱码问题；一个例子： 123456header(\"Content-type:text/html;charset=GBK\");$str = \"叫你姨\";$str = iconv('UTF-8','GBK', $str);$rs= iconv('UTF-8','GBK', '心');$str = str_replace($rs, '', $str);echo $str; 猜猜会输出什么？ 过程 通过bin2hex($str)转码： 叫你姨的GBK编码为BDD0 C4E3 D2CC， 心的GBK编码为D0C4 经过str_replace的替换，结果就变成了BDE3 D2CC echo pack(‘N’, hexdec(‘BDE3D2CC’)); 结果是：姐姨 continue回到这个问题，替换前的转码为： 13c703ed7f7ceaab7f0bdccd2d5caf5c6b7a3acccc6bfa8d3d0c7e5bebbb5c4cff3d5f7d2e2d2e5a3acbeadb9fd266c6471756f3bbfaab9e226726471756f3bb5c4ccc6bfa8d4dab1b3baf3bfc9bfb4b5bd2220cecb22a1a22220b0a122a1a22220bae422a3a8d2f4d2eba3a9c8fdb8f6e8f3cec4d7d6a3acbfaab9e2baf3b5c4ccc6bfa8d2d4b9a9b7eed4dacbc2d4babbf2bcd2d6d0b7f0ccc3ceaad2cba3bbceb4beadbfaab9e2b5c4ccc6bfa8bfc9d7f7ceaad2d5caf5c6b7b0dab9d2d4dabcd2cda5b8c9bebbb4a6a3acc8e7bfcdccfca1a2cae9b7bfa3accac7c7e5bebbc9edd0c4a1a2c6b7ceb6b8dfd1c5b5c4d2d5caf5bcd1c6b7a1a33c6272202f3e4173204275646468697374206172742c205468616e676b612068617320636c65616e20616e6420707572652073796d626f6c697a6174696f6e2e20416674657220226f70656e696e67206c6967687422207468726565205661746963616e207465787420266d646173683b266d646173683b224f6d222c20224168222c2022486f6e672220287472616e736c697465726174696f6e292063616e206265207365656e20696e20746865206261636b67726f756e64206f66207468616e676b612e205468656e207468616e676b612073686f756c6420626520617070726f7072696174656c7920776f727368697070656420696e207468652074656d706c65206f7220612066616d696c792068616c6c20666f7220776f727368697070696e67204275646468612e20576974686f7574206265696e67206f70656e6564206c696768742c207468616e676b612063616e2062652068616e67656420696e206120636c65616e20706c6163652c2073756368206173206c6976696e6720726f6f6d206f722073747564792e205468616e676b612069732074686520617274206f6620656c6567616e742074617374652077686963682063616e20616c736f2068656c7020707572696679206d656e74616c6974792e3c2f703e 替换后的转码为： 13c703ed7f7ceaab7f0bdccd2d5caf5c6b7a3acccc6bfa8d3d0c7e5bebbb5c4cff3d5f7d2e2d2e5a3acbeadb9fd266c6471756f3bbfaab9e226726471756f3bb5c4ccc6bfa8d4dab1b3baf3bfc9bfb4b5bd5c2220cecb5c22a1a25c2220b0a15c22a1a25c2220bae422a3a8d2f4d2eba3a9c8fdb8f6e8f3cec4d7d6a3acbfaab9e2baf3b5c4ccc6bfa8d2d4b9a9b7eed4dacbc2d4babbf2bcd2d6d0b7f0ccc3ceaad2cba3bbceb4beadbfaab9e2b5c4ccc6bfa8bfc9d7f7ceaad2d5caf5c6b7b0dab9d2d4dabcd2cda5b8c9bebbb4a6a3acc8e7bfcdccfca1a2cae9b7bfa3accac7c7e5bebbc9edd0c4a1a2c6b7ceb6b8dfd1c5b5c4d2d5caf5bcd1c6b7a1a33c6272202f3e4173204275646468697374206172742c205468616e676b612068617320636c65616e20616e6420707572652073796d626f6c697a6174696f6e2e204166746572205c226f70656e696e67206c696768745c22207468726565205661746963616e207465787420266d646173683b266d646173683b5c224f6d5c222c205c2241685c222c205c22486f6e675c2220287472616e736c697465726174696f6e292063616e206265207365656e20696e20746865206261636b67726f756e64206f66207468616e676b612e205468656e207468616e676b612073686f756c6420626520617070726f7072696174656c7920776f727368697070656420696e207468652074656d706c65206f7220612066616d696c792068616c6c20666f7220776f727368697070696e67204275646468612e20576974686f7574206265696e67206f70656e6564206c696768742c207468616e676b612063616e2062652068616e67656420696e206120636c65616e20706c6163652c2073756368206173206c6976696e6720726f6f6d206f722073747564792e205468616e676b612069732074686520617274206f6620656c6567616e742074617374652077686963682063616e20616c736f2068656c7020707572696679206d656e74616c6974792e3c2f703e 即将22替换为5c22，替换结果中确实有一处的22未被替换。而这个22就是导致报错的问题了，为啥没有替换，猜想难道是22在str_replace的时候被前后分开了，但并没有… Why?在本地环境中，通过对上面的编码，进行翻转，未能复现线上的效果，这是啥原因呢？ 123456&lt;?phpheader(\"Content-type: text/html; charset=gbk\"); $content = file_get_contents('./content.txt');$str = pack(\"H*\", $content) ;$str = str_replace('\"','\\\"',$str);echo $str; 解决方案这类的问题解决方案其实也很多，比如： 将内容转换为UTF-8，进行替换，替换完了，再转成GBK； 使用双字节可靠的mb_ereg_replace进行替换；","categories":[],"tags":[{"name":"gbk","slug":"gbk","permalink":"http://jinzhan.github.io/tags/gbk/"},{"name":"php","slug":"php","permalink":"http://jinzhan.github.io/tags/php/"}]},{"title":"javascript前端模板","slug":"2015/javascript-replace","date":"2015-12-26T10:26:39.000Z","updated":"2018-11-25T16:08:34.371Z","comments":true,"path":"12/26/2015/javascript-replace/","link":"","permalink":"http://jinzhan.github.io/12/26/2015/javascript-replace/","excerpt":"","text":"ECMASript 6模板语法字符串模板 1234567let name = 'steinitz';console.log(`My name is $&#123;name&#125;`); // My name is steinitzvar a = 5;var b = 8;console.log(`$&#123;a&#125; x $&#123;b&#125; = $&#123;a*b&#125;`); // 5 x 8 = 40 标签模板： 123var a = 5;var b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`; 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 tag函数所有参数的实际值如下。 第1个参数：[‘Hello ‘, ‘ world ‘] 第2个参数: 15 第3个参数：50 tag函数实际上以下面的形式调用：tag([&#39;Hello &#39;, &#39; world &#39;], 15, 50); 12345678910// 一个例子，标签模板的用法极为灵活var a = 5;var b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;function tag(arr, i1, i2) &#123; console.log(arr); console.log(i1*i2); return 'Yes!';&#125; 构造前端模板强大的replace函数 1234567function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(' - ');&#125;// will return: 'abc - 12345 - #$*%':var newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); 稍微修改下： 1234567891011121314var html = function(tmpl, data) &#123; return tmpl.replace(/\\$\\&#123;(\\w+)\\&#125;/g, function(word, key) &#123; return data[key]; &#125;);&#125;;// examplevar tmpl = 'My name is $&#123;name&#125;, I am working in $&#123;place&#125;';console.log(html(tmpl, &#123; name: 'Steinitz', place: 'Beijing'&#125;)); // My name is Steinitz, I am working in Beijing","categories":[],"tags":[{"name":"replace","slug":"replace","permalink":"http://jinzhan.github.io/tags/replace/"},{"name":"javascript","slug":"javascript","permalink":"http://jinzhan.github.io/tags/javascript/"}]},{"title":"前端一些小技巧","slug":"2015/tips-2015-11","date":"2015-11-07T03:21:13.000Z","updated":"2018-11-25T16:08:34.372Z","comments":true,"path":"11/07/2015/tips-2015-11/","link":"","permalink":"http://jinzhan.github.io/11/07/2015/tips-2015-11/","excerpt":"","text":"diff的时候排除svn文件夹1diff -r ihome.1.0.196 ihome.trunk --exclude='.svn' ajax的全局函数123456/* 前端hack，设置完成，即升级 */$(document).ajaxSuccess(function (event, xhr, settings) &#123; if (~settings.url.indexOf('/submit/user')) &#123; me.jumpTo(3); &#125;&#125;); 前端添加anti-CSRF","categories":[],"tags":[]},{"title":"Meteor学习笔记","slug":"2015/discover-meteor","date":"2015-10-25T12:13:23.000Z","updated":"2018-11-25T16:08:34.371Z","comments":true,"path":"10/25/2015/discover-meteor/","link":"","permalink":"http://jinzhan.github.io/10/25/2015/discover-meteor/","excerpt":"","text":"创建项目meteor create microscope 四个子文件夹： /client /server /public /lib 说明 在 /server 文件夹中的代码只会在服务器端运行。 在 /client 文件夹中的代码只会在客户端运行。 其它代码则将同时运行于服务器端和客户端上。 请将所有的静态文件（字体，图片等）放置在 /public 文件夹中 在 /lib 文件夹中的文件将被优先载入。 所有以 main.* 命名的文件将在其他文件载入后载入。 其他文件以文件名的字母顺序载入。 文件名称和路径不重要 Meteor 的强大之处在于文件的查找。无论你把代码文件放在 /client 目录下的任何地方，Meteor 都可以找到它并且正确地进行编译。这意味着你永远都不需要手动编写 JavaScript 或 CSS 文件的调用路径。 模板系统 Spacebars Inclusion Expression Block Helper 代码所在的目录既不是 client/ 也不是 server/ 所以 Posts 会共同存在运行在服务器和客户端 存储数据 浏览器内存：像 JavaScript 变量的这些数据会保存在浏览器内存中，意味着他们不是永久性的：它们存在于当前浏览器标签中，当标签关闭后它们会消失。 浏览器存储：浏览器也可存储较为永久性的数据，使用 cookies 或本地存储 Local Storage。虽然数据会在不同 session 间保持，但是只是针对于当前用户（包括标签之间）但不能轻易地共享给其他用户。 服务器端数据库：你想永久保存数据并且提供给多个用户的最好方法是数据库（MongoDB 是 Meteor 应用默认的方案）。 console，console 与 console第1个： 由操作系统启动服务器端 console.log() 会输出到这里有 $ 提示符通常也被成为外壳程序 Shell，Bash 第2种：在浏览器内启动，执行 Javascript 代码客户端的 console.log() 会输出到这里提示符是 ❯也通常被称作 Javascript 控制台或者开发工具控制台（DevTools Console） 第3种：从终端由 meteor mongo 或者 mrt mongo 来启动你可以在这里直接操作 App 的数据库提示符 &gt;也被称作 Mongo 控制台 (Mongo Console)客户端集合 客户端的集合更加有趣。当你在客户端申明 Posts = new Mongo.Collection(‘posts’); 你实际上是创建了一个本地的，在浏览器缓存中的真实的 Mongo 集合。 当我们说客户端集合被”缓存”是指它保存了你数据的一个子集，而且对这些数据提供了十分快速的访问。 有一点我们必须要明白，因为这是 Meteor 工作的一个基础: 通常说来，客户端的集合的数据是你 Mongo 数据库的所有数据的一个子集（毕竟我们不会想把整个数据库的数据全传到客户端来）。 第二，那些数据是被存储在浏览器内存中的，也就是说访问这些数据几乎不需要时间，不像去服务器访问 Posts.find()那样需要等待，因为数据事实上已经载入了。 介绍 MiniMongoMeteor 的客户端 Mongo 的技术实现被成为 MiniMongo。它目前还不是一个完美的实现，而且你会发现偶尔 Mongo 的功能在这里不能实现。不过本书中涉及到的功能都是可以在 Mongo 和 MiniMongo 中实现的。 meteor reset:清空数据库初始化 查找与提取 在 Meteor 中，find() 返回值是一个游标。游标是一种从动数据源。如果你想输出内容，你可以对游标使用 fetch()来把游标转换成数组。 Meteor 十分智能地在应用中保持游标状态而避免动不动就把游标变成数组。这就造成了你不会经常在 Meteor 代码中看到 fetch() 被调用（基于同样原因，我们在上述例子中也没有使用 fetch ）。 autopublish autopublish:让我们的客户端可以镜像般地得到数据库中的所有帖子 meteor remove autopublish meteor add iron:router Loading模板meteor add sacha:spin1&lt;template name=\"loading\"&gt; &#123;&#123;&gt;spinner&#125;&#125; &lt;/template&gt; dataNotFound hookRouter.onBeforeAction(‘dataNotFound’, {only: ‘postPage’});这会告诉 Iron Router 不仅在非法路由情况下，而且在 postPage 路由，每当 data 函数返回“falsy”（比如null、false、undefined 或 空）对象时，显示“无法找到”的页面 动态代码重载技术 手动去重载浏览器窗口，自然就会丢失我们的 Session 变量（因为这将会创建一个新的会话）引发动态代码重载（即，通过修改并保存我们的源文件）去重新加载页面，Session 变量却仍然存在 Package meteor add twbs:bootstrap meteor add underscore autorun 每一次 autorun 上下文中的响应式数据源发生变化的时候，autorun 函数就会自动运行 Tracker.autorun( function() { console.log(‘Value is: ‘ + Session.get(‘pageTitle’)); } ); 发布时删除辅助包 meteor remove insecure 发布与订阅1234// 在服务器端Meteor.publish('posts', function(author) &#123; return Posts.find(&#123;flagged: false, author: author&#125;);&#125;); 然后我们在客户端订阅这个发布时定义同一个参数。 // 在客户端Meteor.subscribe(‘posts’, ‘bob-smith’); 让meteor在后台运行screen meteor","categories":[],"tags":[{"name":"meteor","slug":"meteor","permalink":"http://jinzhan.github.io/tags/meteor/"}]},{"title":"一个简单的概率问题","slug":"2015/lottery-probability","date":"2015-09-27T01:32:42.000Z","updated":"2018-11-25T16:08:34.372Z","comments":true,"path":"09/27/2015/lottery-probability/","link":"","permalink":"http://jinzhan.github.io/09/27/2015/lottery-probability/","excerpt":"","text":"context网上看到一道题目，5枚硬币随意抛，求3枚以上朝上的可能性 排列组合排列从n个不同的元素中取m(m≤n)个元素，按照一定的顺序排成一排，叫做从n个不同的元素中取m个元素的排列。排列数：从n个不同的元素中取m(m≤n)个元素的所有排列的个数，叫做从n个不同元素中取出m个元素的排列数，记为Anm排列公式：A(n,m)=n!/(n-m)!，即：A(n,m)=n(n-1)…..(n-m+1) 组合从n个不同的元素中，任取m(m≤n)个元素并成一组，叫做从n个不同的元素中取m个元素的组合。组合数：从n个不同的元素中取m(m≤n)个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数，记为Cnm组合公式：C(n,m)=A(n,m)/m!=n!/(m!*(n-m)!) Code12345678910111213141516171819202122/** @param &#123;number&#125; m* @param &#123;number&#125; n* @param &#123;number&#125; f* @return &#123;number&#125;*/function posibility(m,n,f)&#123; f = +f || 5; var allPosibility = Math.pow(2,m); // n枚硬币朝上，组合：cmn = m!/n!*(m-n)! var mFactorial = 1; for(var i=m-n+1;i&lt;=m;i++)&#123; mFactorial *= i; &#125; for(var i=1;i&lt;=n;i++)&#123; mFactorial /= i; &#125; return +(mFactorial/allPosibility).toFixed(f);&#125; result 答案是： posibility(5,3) + posibility(5,4) + posibility(5,5) 等价于：1 - (posibility(5,2) + posibility(5,1) + posibility(5,0))","categories":[],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://jinzhan.github.io/tags/algorithms/"}]},{"title":"javascript中位运算符的应用","slug":"2015/operator","date":"2015-09-20T12:29:44.000Z","updated":"2018-11-25T16:08:34.372Z","comments":true,"path":"09/20/2015/operator/","link":"","permalink":"http://jinzhan.github.io/09/20/2015/operator/","excerpt":"","text":"review位运算符即按照内存中的位来操作数值，因此具有更好的性能。位运算符有： ~ 按位非(NOT) &amp; 按位与(AND) | 按位或(OR) XOR 按位异或(XOR) &lt;&lt; 左移 &gt;&gt; 右移 &gt;&gt;&gt; 无符号右移 位运算符属于最基层的操作，在数值逻辑的处理过程中，应该优先被考虑。 practice来看一个case： 题1 1在一个整数数组中，除了1个数只出现1次，其他每个数都出现2次，找出这个数。 解 考虑到这篇文章的主题，聪明的你应该已经想到了，这里使用异或，能最优雅的解决该问题。 1234567891011/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; var ret = nums[0]; for(var i=1,len = nums.length;i&lt;len;i++) &#123; ret ^= nums[i]; &#125; return ret;&#125;; 用es6 再简洁一点 123var singleNumber = function(nums) &#123; return nums.reduce((pre, cur) =&gt; pre ^= cur);&#125;; refer 注意：二进制中负数是以二进制补码存储步骤如下： 首先求该负数的绝对值码； 求二进制反码，即将0替换为1，1替换为0； 在得到的二进制码反码上加1； 如：-18 绝对值码：0000 0000 0000 0000 0000 0000 0010 0010 二进制反码：1111 1111 1111 1111 1111 1111 1101 1101 加上1：1111 1111 1111 1111 1111 1111 1101 1110 下面，来个升级版： 题2 1在一个整数数组中，除了2个数只出现1次，其他每个数都出现2次，找出这2个数。 Analysis 同上，这个依然要用到异或； 那么，如何将最终的结果(即：所求之数的异或结果）分解出来呢 解 1234567891011121314151617181920212223/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var singleNumber = function(nums) &#123; // 第1步获得2个数的异或结果 var num = nums[0]; var len = nums.length; for(var i = 1;i&lt;len;i++) &#123; num ^= nums[i]; &#125; // 第2步是关键，num与-num按位与，得到num和-num都为1的位组成的数 num &amp;= -num; // 第3步，再遍历一次数组 var a = 0; var b = 0; for(i = 0;i&lt;len;i++) &#123; num &amp; nums[i] ? (a ^= nums[i]) : (b ^= nums[i]); &#125; return [a, b]&#125;; refer plus位操作的使用也能让代码变得更优雅： ~location.indexOf(‘baidu.com’) // 只有-1按位非为0 Math.random()*100 ^ 0 // 得到0~100(不含100)之间的随机数 ~new Date // 加时间戳","categories":[{"name":"algorithms","slug":"algorithms","permalink":"http://jinzhan.github.io/categories/algorithms/"}],"tags":[{"name":"operator","slug":"operator","permalink":"http://jinzhan.github.io/tags/operator/"}]},{"title":"linux下的常用命令","slug":"2015/linux-common-commands","date":"2015-05-25T12:16:18.000Z","updated":"2018-11-25T16:08:34.372Z","comments":true,"path":"05/25/2015/linux-common-commands/","link":"","permalink":"http://jinzhan.github.io/05/25/2015/linux-common-commands/","excerpt":"","text":"文件处理exec的语法 1find . -name '*.js' -exec grep 'title' -rl &#123;&#125; \\; xargs: 给命令传递参数的过滤器 12345678910# 统计js的数量find . -name '*.js' | wc -l# 统计js文件的行数find . -name '*.js' | xargs wc -l# plusfind . -name '*.js' | xargs wc -l | sort -k2cat url-list.txt | xargs wget –c 批量替换 12# 反引号可以用$()sed -i '' \"s/common\\/data/ipad\\/data/g\" `grep common\\/data * --exclude-dir=\\.svn -rl` vi中的快速注释(其实就是正则) 12345678假设是.php3,5 s/^/#/g 注释第3-5行3,5 s/^#//g 解除3-5行的注释1,$ s/^/#/g 注释整个文档。:%s/^/#/g 注释整个文档，此法更快。 awk神器 12345678910111213# 被修改的文件svn st | grep -e 'template/|static/' | grep -e 'M|?' | awk '&#123;print $2&#125;'# 获取文件前10行awk 'FNR == 10 &#123;print &#125;' file.txt# ORawk 'NR == 10' file.txt# ORsed -n10p file.txt# ORtail -n+10 file.txt|head -1 系统命令活动的进程 123ps -ef 查看正在活动的进程ps -ef |grep abc 查看含有\"abc\"的活动进程ps -ef |grep -v abc 查看不含abc的活动进程 后台运行 1nohup sh test.sh &amp;&gt;/dev/null &amp;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://jinzhan.github.io/tags/linux/"}]},{"title":"使用jquery来绘制气泡效果","slug":"2014/generate-bubbles","date":"2014-09-23T05:44:15.000Z","updated":"2018-11-25T16:08:34.370Z","comments":true,"path":"09/23/2014/generate-bubbles/","link":"","permalink":"http://jinzhan.github.io/09/23/2014/generate-bubbles/","excerpt":"","text":"//生成气泡 var makeBubble = function(){ new Bubble(\"#y4-char\",{ a:0.015, b:0.2, c:100, color:\"#f8e8e8\" }); setTimeout(function(){ new Bubble(\"#y4-char\",{ a:0.01, b:0.2, c:100, color:\"#ffee52\" }); },600); setTimeout(function(){ new Bubble(\"#y4-char\",{ a:-0.01, b:0.2, c:150, color:\"#fffacb\" }); },1200); setTimeout(function(){ new Bubble(\"#y4-char\", { a:0.015, b:0.2, c:100, color:\"#288911\" }); },1800); setTimeout(function(){ new Bubble(\"#y4-char\",{ a:-0.01, b:0.25, c:150, color:\"#e7d2e6\" }); },2400); setTimeout( function(){ new Bubble(\"#y4-char\",{ a:0.015, b:0.2, c:200, d: 50, color:\"#f8e8e8\" }) },200 ) setTimeout(function(){ new Bubble(\"#y4-char\",{ a:0.01, b:0.2, c:300, d: 100, color:\"#ffee52\" }); },400); setTimeout(function(){ new Bubble(\"#y4-char\",{ a:-0.01, b:0.2, c:450, d: 30, color:\"#fffacb\" }); },1000); setTimeout(function(){ new Bubble(\"#y4-char\", { a:0.015, b:0.2, c:-100, d: 40, color:\"#288911\" }); },1500); setTimeout(function(){ new Bubble(\"#y4-char\",{ a:-0.01, b:0.25, c:-150, d: 60, color:\"#e7d2e6\" }); },2000); //递归调用 setTimeout(makeBubble,6000); }; makeBubble(); 相关代码","categories":[],"tags":[]}]}